--------------------------------------------------- Active Record Query Interface --------------------------------------------------

 -> Active Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB,
    PostgreSQL, and SQLite. Regardless of which database system you're using, the Active Record method format will always be the same.
    
 1). Retrieving Objects from the Database.
 -> To retrieve objects from the database, Active Record provides several finder methods. 
 -> Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.

     a). Retrieving a Single Object :-
	-> Active Record provides several different ways of retrieving a single object.
	
	*). find :- can retrieve the object corresponding to the specified primary key that matches any supplied options.
	
		eg:- 3.2.1 :001 > Book.find(1)           #find using id
                                 
			 id: 1,                                                     
			 name: "Harry potter",                                      
			 book_type: "fiction",                                      
			 created_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00,
			 updated_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00> 
			 
		     3.2.1 :002 > Book.find([1,3])      #find two books using id
						        
			  id: 1,                                                    
			  name: "Harry potter",                                     
			  book_type: "fiction",                                     
			  created_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00,
			  updated_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00>,
			
			  id: 3,
			  name: "And Then There Were None",
			  book_type: "Mystery",
			  created_at: Thu, 30 Mar 2023 08:54:11.346950000 UTC +00:00,
			  updated_at: Thu, 30 Mar 2023 08:54:11.346950000 UTC +00:00>] 
		
	*). take :- The take method retrieves a record without any implicit ordering.  # (bang version take!)
	 
	 	eg:-  3.2.1 :004 > Book.take                                
			 id: 1,                                                     
			 name: "Harry potter",                                      
			 book_type: "fiction",                                      
			 created_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00,
			 updated_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00> 
			 
		      3.2.1 :005 > Book.take(2)                              
			  id: 1,                                                    
			  name: "Harry potter",                                     
			  book_type: "fiction",                                     
			  created_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00,
			  updated_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00>,

			  id: 2,
			  name: "The Hobbit ",
			  book_type: "Fantasy",
			  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,
			  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>] 
	
	*). first :- The first method finds the first record ordered by primary key (default).  # (bang version first!)
	
		eg:-  3.2.1 :007 > Author.first                                  
			 id: 1,                                                       
			 name: "JK Rowling",                                          
			 book_id: 1,                                                  
			 created_at: Thu, 30 Mar 2023 08:57:18.310960000 UTC +00:00,  
			 updated_at: Thu, 30 Mar 2023 08:57:18.310960000 UTC +00:00>  
			 
		      3.2.1 :008 > Author.first(2)                                
			  id: 1,                                                      
			  name: "JK Rowling",                                         
			  book_id: 1,                                                 
			  created_at: Thu, 30 Mar 2023 08:57:18.310960000 UTC +00:00,
			  updated_at: Thu, 30 Mar 2023 08:57:18.310960000 UTC +00:00>,
			 #<Author:0x00007fc7bb1f0470
			  id: 2,
			  name: "JRR Tolkien",
			  book_id: 2,
			  created_at: Thu, 30 Mar 2023 09:03:00.244777000 UTC +00:00,
			  updated_at: Thu, 30 Mar 2023 09:03:00.244777000 UTC +00:00>] 
	
	*). last :- The last method finds the last record ordered by primary key (default).  # (bang version last!)
	
		eg:-  3.2.1 :009 > Author.last                                 
			 id: 6,                                                       
			 name: "Charles Dickens",                                     
			 book_id: 3,                                                  
			 created_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00,  
			 updated_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00>  
			 
		      3.2.1 :010 > Author.last(2)                                 
			  id: 5,                                                      
			  name: "Charles Dickens",                                    
			  book_id: 5,                                                 
			  created_at: Thu, 30 Mar 2023 09:03:00.257843000 UTC +00:00, 
			  updated_at: Thu, 30 Mar 2023 09:03:00.257843000 UTC +00:00>,
						      
			  id: 6,                                                      
			  name: "Charles Dickens",                                    
			  book_id: 3,                                                 
			  created_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00, 
			  updated_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00>] 

		
	*). find_by :- The find_by method finds the first record matching some conditions.  # (bang version find_by!)
	
		eg:-  3.2.1 :012 > Publisher.find_by(name: "Pan Macmillan India")             
			 id: 5,                                                          
			 name: "Pan Macmillan India",                                    
			 book_id: 5,                                                     
			 created_at: Thu, 30 Mar 2023 10:22:22.766797000 UTC +00:00,     
			 updated_at: Thu, 30 Mar 2023 10:22:22.766797000 UTC +00:00>  
		
     ---------------------------------------------------------------------------------------------------------------------
     		
     b). Retrieving Multiple Objects in Batches:-
     	
     	*). find_each :- Method fetches a batch of records and yields each of them to the provided block, instead of loading all 
     	                 the records into memory at once. This method is best used when you need to process the records one by one.
     	                 
		eg:-    3.2.1 :016 > Book.find_each do |book|
			3.2.1 :017 >   puts book.name
			3.2.1 :018 > end
		output:-	  
			Harry potter
			The Hobbit 
			And Then There Were None
			The Little Prince
			A Tale Of Two Cities
			Harry Potter and the Sorcerer’s Stone
			 => nil 
			 
	 options:-
	 	
 	i). batch_size :- it allows you to specify the number of records to be retrieved in each batch.
 	
	eg:-   3.2.1 :019 > Book.find_each(batch_size: 3) do |book|     #every batch size is 3 here.
		3.2.1 :020 >   puts book.name
		3.2.1 :021 > end
		
	  output:-
	  
	    batch 1:-
	    	Harry potter
		The Hobbit 
		And Then There Were None
		  
            batch 2:-
		The Little Prince
		A Tale Of Two Cities
		Harry Potter and the Sorcerer’s Stone
		 
	ii). start and finish :- 
		-> The :start option allows you to configure the first ID of the sequence.
		-> :finish allows you to configure the last ID of the sequence.
	NOTE :- we can use this start and finish separately.
	
		eg :-
			3.2.1 :022 > Author.find_each(start: 2, finish: 5) do |auth|
			3.2.1 :023 >   puts auth.name
			3.2.1 :024 > end
			
		  output :-
			JRR Tolkien
			Agatha Christie
			Antoine de Saint-Exupéry
			Charles Dickens
			 => nil 

     	*). find_in_batches :- method fetches a batch of records and returns them as an array, instead of yielding them one by one. 
     	    This method is best used when you need to perform an operation on a batch of records, such as updating or deleting them.
     	    
     	    	eg :-
     	    	3.2.1 :043 > Book.find_in_batches(batch_size: 3) do |batch|      #first convert into batches in array form
		3.2.1 :044 >   batch.each do |book|				    # iterate each book of batch one by one.
		3.2.1 :045 >     puts book.name
		3.2.1 :046 >   end
		3.2.1 :047 > end
		  
		  output :-
		     batch 1:-
		     
			Harry potter
			The Hobbit 
			And Then There Were None
			
		     batch 2:- 
			The Little Prince
			A Tale Of Two Cities
			Harry Potter and the Sorcerer’s Stone
			
	 i). start and finish options :-
	 
	 	eg :-
	 	3.2.1 :053 > Book.find_in_batches(start: 3,finish: 4) do |batch|
		3.2.1 :054 >   batch.each do |book|
		3.2.1 :055 >     puts book.name
		3.2.1 :056 >   end
		3.2.1 :057 > end
		 
		    output :-                         
			And Then There Were None                                     
			The Little Prince                                            
			 => nil 
			 
------------------------------------------------------------------------------------------------------------------------------------

 2). Conditions.
 -> The where method allows you to specify conditions to limit the records returned, representing the WHERE-part of the SQL statement.
    Conditions can either be specified as a string, array, or hash.
    
    a). Pure String Conditions
    
    	eg :- 3.2.1 :058 > Book.where("book_type = 'fiction'")
	      output :-
	                                         
		  id: 1,                                                     
		  name: "Harry potter",                                      
		  book_type: "fiction",
		  created_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 08:49:06.338483000 UTC +00:00>,
		
		  id: 5,
		  name: "A Tale Of Two Cities",
		  book_type: "fiction",
		  created_at: Thu, 30 Mar 2023 08:54:11.352993000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 08:54:11.352993000 UTC +00:00>,
		
		  id: 6,
		  name: "Harry Potter and the Sorcerer’s Stone",
		  book_type: "fiction",
		  created_at: Fri, 31 Mar 2023 10:17:29.648225000 UTC +00:00,
		  updated_at: Fri, 31 Mar 2023 10:17:29.648225000 UTC +00:00>] 

    b). Array Conditions
    
    	eg 1 :- 
    	  3.2.1 :083 > Book.where(["name = ?","The Hobbit "])
              
        output :-     
	  id: 2,
	  name: "The Hobbit ",
	  book_type: "Fantasy",
	  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>] 
	  
	eg 2 :-
	3.2.1 :084 > params = {name: "The Hobbit "}
	 => {:name=>"The Hobbit "} 
	3.2.1 :085 > book = Book.where("name = ?", params[:name])
	3.2.1 :086 > book

	output :-
	  id: 2,                 
	  name: "The Hobbit ",   
	  book_type: "Fantasy",  
	  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>] 
	  
	i). Conditions That Use LIKE
	-> Although condition arguments are automatically escaped to prevent SQL injection, SQL LIKE wildcards (i.e., % and _) are not
	   escaped. This may cause unexpected behavior if an unsanitized value is used in an argument.
	   
	   eg :-
	   3.2.1 :087 > Book.where("name LIKE ?", params[:name] + "%")      #Book Load (0.6ms)

	     output:-
		  id: 2,
		  name: "The Hobbit ",
		  book_type: "Fantasy",
		  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>] 
		  
	  NOTE :- this may also prevent the database from using an intended index, leading to a much slower query.
	  
	  -> To avoid these problems, use sanitize_sql_like to escape wildcard characters in the relevant portion of the argument:
	  eg :-
	  	3.2.1 :088 > Book.where("name LIKE ?",Book.sanitize_sql_like(params[:name]) + "%")    #Book Load (0.5ms)
		   
	     output:-
		  id: 2,
		  name: "The Hobbit ",
		  book_type: "Fantasy",
		  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>] 

    c). Hash Conditions
	-> Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax.
	NOTE :- Only equality, range, and subset checking are possible with Hash conditions.
	
	i). Equality Conditions :-
	
		eg:- first way
		
		3.2.1 :089 > Record.where(borrowed: true)
 
 		output :-
		  id: 1,
		  borrowed: true,
		  book_record_id: 2,
		  created_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00>,

		  id: 3,
		  borrowed: true,
		  book_record_id: 3,
		  created_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00>] 
		  
		eg:- second way
		
		3.2.1 :090 > Record.where("borrowed" => true)     #using string
		  
		output :-
		  id: 1,
		  borrowed: true,
		  book_record_id: 2,
		  created_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00>,
		 
		  id: 3,
		  borrowed: true,
		  book_record_id: 3,
		  created_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00>] 

	ii). Range Conditions     #can use as between in postgres
		eg :-
		
		3.2.1 :093 > Book.where(created_at: (Time.now.midnight - 3.day)..Time.now.midnight)
  		
  		output :-
		  id: 6,
		  name: "Harry Potter and the Sorcerer’s Stone",
		  book_type: "fiction",
		  created_at: Fri, 31 Mar 2023 10:17:29.648225000 UTC +00:00,
		  updated_at: Fri, 31 Mar 2023 10:17:29.648225000 UTC +00:00>] 

	iii). Subset Conditions
	   -> If you want to find records using the IN expression you can pass an array to the conditions hash:
	   
	   	eg :-
	   	3.2.1 :094 > Record.where(book_record_id: [1,3])

		output :-
		  id: 3,
		  borrowed: true,
		  book_record_id: 3,
		  created_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00>,

		  id: 4,
		  borrowed: false,
		  book_record_id: 1,
		  created_at: Thu, 30 Mar 2023 13:33:09.869023000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:33:09.869023000 UTC +00:00>] 

	iv). NOT Conditions
	  -> NOT SQL queries can be built by where.not
	  
	  	eg :-
	  	3.2.1 :095 > Record.where.not(book_record_id: [1,3,4])
 
 		output :-
		  id: 1,
		  borrowed: true,
		  book_record_id: 2,
		  created_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00>] 

	v). OR Conditions
	  -> OR conditions built by calling or on the first relation, and passing the second one as an argument.
	  
	  	eg :-
	  	3.2.1 :098 > Book.where(book_type: 'Fantasy').or(Book.where(book_type: 'Mystery'))
                  
               output :-                                         
		  id: 2,                                                                                  
		  name: "The Hobbit ",                                                                    
		  book_type: "Fantasy",                                                                   
		  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,                             
		  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>,                            
				                                               
		  id: 3,                                                                                  
		  name: "And Then There Were None",
		  book_type: "Mystery",
		  created_at: Thu, 30 Mar 2023 08:54:11.346950000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 08:54:11.346950000 UTC +00:00>] 
		  
	vi). AND Conditions
	   -> AND conditions can be built by chaining where conditions.
	   
	   	eg :-
	   	3.2.1 :103 > Book.where(id: [1, 2]).and(Book.where(id: [2, 3]))
  		
  		output :-
		  id: 2,                 
		  name: "The Hobbit ",   
		  book_type: "Fantasy",  
		  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>] 

------------------------------------------------------------------------------------------------------------------------------------

 3). Ordering
   -> To retrieve records from the database in a specific order, you can use the order method.
   
   	:- Order by single field
   		-> Book.order(:created_at)
   		-> Book.order("created_at")   #we can also use string as parameter.
   		-> Book.order(created_at::desc)
   		-> Book.order(created_at::asc)
   		
   	:- Ordering by multiple field
   		-> Book.order(name::asc , created_at::desc)
   		
   	:- Order multiple times
   		-> Book.order("name ASC").order("created_at DESC")
   
   eg :-
	   3.2.1 :107 > Record.order(book_record_id: :desc)
	   
	output:-       
	  id: 2,                                   
	  borrowed: false,                         
	  book_record_id: 4,                       
	  created_at: Thu, 30 Mar 2023 13:33:09.858600000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 13:33:09.858600000 UTC +00:00>,
		     
	  id: 3,                                   
	  borrowed: true,                          
	  book_record_id: 3,                       
	  created_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 13:33:09.863343000 UTC +00:00>,
		     
	  id: 1,
	  borrowed: true,
	  book_record_id: 2,
	  created_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00>,

	  id: 4,
	  borrowed: false,
	  book_record_id: 1,
	  created_at: Thu, 30 Mar 2023 13:33:09.869023000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 13:33:09.869023000 UTC +00:00>]
	  
----------------------------------------------------------------------------------------------------------------------------------

 4). Selecting Specific Fields
   -> By default, Model.find selects all the fields from the result set using select *.
   
   a). select particular column from the database using the query in rails.
   	
   	eg 1:- 3.2.1 :109 > Book.select(:name)
	
	output :-                                                                
		[#<Book:0x00007fc7bb1f0290 id: nil, name: "Harry potter">,              
		 #<Book:0x00007fc7bb1f01f0 id: nil, name: "The Hobbit ">,               
		 #<Book:0x00007fc7bb1f0150 id: nil, name: "And Then There Were None">,  
		 #<Book:0x00007fc7bb1f00b0 id: nil, name: "The Little Prince">,         
		 #<Book:0x00007fc7bb1f0010 id: nil, name: "A Tale Of Two Cities">,      
		 #<Book:0x00007fc7bd32f960 id: nil, name: "Harry Potter and the Sorcerer’s Stone">] 

	eg 2:- 3.2.1 :110 > Feedback.select(:content, :feedbackable_type)
              
        output :-                                                      
		[#<Feedback:0x00007fc7bae361e0 id: nil, content: "This book is great!", feedbackable_type: "Book">,
		 #<Feedback:0x00007fc7bd40a6f0 id: nil, content: "interesting book", feedbackable_type: "Book">,
		 #<Feedback:0x00007fc7bd40a650 id: nil, content: "i like your book harry potter", feedbackable_type: "Author">] 

   b). for uniq element only.
   
   	eg :- 3.2.1 :111 > Book.select(:book_type).distinct
            
            output :-                                                           
		[#<Book:0x00007fc7bd42f658 id: nil, book_type: "fiction">,                 
		 #<Book:0x00007fc7bd42f5b8 id: nil, book_type: "Adventure">,               
		 #<Book:0x00007fc7bd42f518 id: nil, book_type: "Fantasy">,                 
		 #<Book:0x00007fc7bd42f478 id: nil, book_type: "Mystery">]  
		 
----------------------------------------------------------------------------------------------------------------------------------- 

 5). Limit and Offset
 -> To apply LIMIT to the "PSQL" fired by the Model.find, you can specify the LIMIT using limit and offset methods on the relation.
 -> You can use limit to specify the number of records to be retrieved.
 -> use offset to specify the number of records to skip before starting to return the records.
 
 	eg for limit :-
	 	3.2.1 :117 > Author.order("id DESC").limit(2)

		  id: 6,
		  name: "Charles Dickens",
		  book_id: 3,
		  created_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00>,
		
		  id: 5,
		  name: "Charles Dickens",
		  book_id: 5,
		  created_at: Thu, 30 Mar 2023 09:03:00.257843000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 09:03:00.257843000 UTC +00:00>] 

	eg for offset :-
		3.2.1 :126 > Author.offset(2).limit(1)
 
		  id: 3,
		  name: "Agatha Christie",
		  book_id: 3,
		  created_at: Thu, 30 Mar 2023 09:03:00.249358000 UTC +00:00,
		  updated_at: Thu, 30 Mar 2023 09:03:00.249358000 UTC +00:00>] 

