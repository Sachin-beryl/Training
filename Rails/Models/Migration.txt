------------------------------------------------------------- Migration ----------------------------------------------------------------

 1). Creating a Migration:-
 
 	a). Creating a Standalone Migration
 	-> Migrations are stored as files in the db/migrate directory.
 	-> The name of the file is of the form YYYYMMDDHHMMSS_create_products.rb
 	
 	-> generate migration:-
 		:- generate migration AddPartNumberToProducts
 		
 	-> Add and remove column:-
 		:- rails generate migration AddPartNumberToProducts part_number:string --force
 
 	-> Add index :-
 		:- rails generate migration AddPartNumberToProducts part_number:string:index
 		
 	-> A migration to remove a column from the command line:
		:- rails generate migration RemovePartNumberFromProducts part_number:string

	-> migration to add details in products
		:- rails g migration AddDetailsToProducts price:decimal
		
	-> create new model user for reference migration work:
		:- rails g model user name:string gender:string
		
	-> Add user reference to product:
		:- rails generate migration AddUserRefToProducts user:references
		
	-> Apply join on user and product model:
		:- rails generate migration CreateJoinTableCustomerProduct user product
		
 2). Writing a Migration:-
 
 	a). Creating a Table

		class CreateUsers < ActiveRecord::Migration[6.1]
		  def change
		    create_table :users do |t|
		      t.string :name, null: false 		 # the name column cannot be null
		      t.string :email, index: { unique: true } # add an index to the email column with unique constraint
		      t.integer :age, default: 18 		 # the age column has a default value of 18
		      t.boolean :active, default: true 	 # the active column has a default value of true
		      t.text :description, limit: 1000 	 # the description column has a maximum length of 1000 characters
		      t.references :account, foreign_key: true, null: false # add a foreign key to the account table and make it required
		      t.timestamps 				 # add timestamps for created_at and updated_at columns
		    end
		  end
		end
		
	b). Creating a Join Table
	
	-> The migration method create_join_table creates an HABTM (has and belongs to many) join table.
		:- create_join_table :products, :categories

	-> which creates a categories_products table with two columns called category_id and product_id. 
	   These columns have the option :null set to false by default. This can be overridden by specifying the :column_options option:

		:- create_join_table :products, :categories, column_options: { null: true }

	-> By default, the name of the join table comes from the union of the first two arguments provided to create_join_table, 
	   in alphabetical order. To customize the name of the table, provide a :table_name option:

		:- create_join_table :products, :categories, table_name: :categorization
		
	-> create_join_table also accepts a block, which you can use to add indices (which are not created by default) 

		:- create_join_table :products, :categories do |t|
		     t.index :product_id
		     t.index :category_id
		   end
		   
	c). Changing Tables
	
	-> A close cousin of create_table is change_table, used for changing existing tables. 
	   It is used in a similar fashion to create_table but the object yielded to the block knows more tricks.
	   
	   	:-     class UseChangeTable < ActiveRecord::Migration[7.0]
			  def change
			    change_table :products do |t|
			      t.remove :description, :name
			      t.string :p_name
			      t.string :part_number
			      t.index :part_number
			    end
			  end
			end
			
	d). Changing Columns
	
	NOTE :- Note that change_column command is irreversible.
	
	-> Like the remove_column and add_column Rails provides the change_column migration method.
	-> Besides change_column, the change_column_null and change_column_default methods are used specifically to change a not null constraint and default values of a column.
	
	eg for default :- change_column_default :products, :approved, from: true, to: false    #(reversible)
	
		:-      class ChangingColumnInUsers < ActiveRecord::Migration[7.0]
			  def change
			    change_column :users, :name, :text
			    change_column_null :users, :created_at, true
			  end
			end
			
	e). Column Modifiers
	
	-> Column modifiers can be applied when creating or changing a column:

	*). comment   :- Adds a comment for the column.
	*). collation :- Specifies the collation for a string or text column.
	*). default   :- Allows to set a default value on the column. Note that if you are using a dynamic value (such as a date), the default will only be calculated the first time (i.e. on the date the migration is applied). Use nil for NULL.
	
	*). limit     :- Sets the maximum number of characters for a string column and the maximum number of bytes for text/binary/integer columns.
	*). null      :- Allows or disallows NULL values in the column.
	*). precision :- Specifies the precision for decimal/numeric/datetime/time columns.
	*). scale     :- Specifies the scale for the decimal and numeric columns, representing the number of digits after the decimal point.
	
		:-      class ApplyColumnModifier < ActiveRecord::Migration[7.0]
			  def change
			    add_column :products, :grade, :string, comment: "grade for product"
			    change_column :products, :price, :integer, default: "zero", precision: 10, scale: 2
			    change_column :products, :part_number, :string, limit: 100, null: false
			  end
			end
			
	f). References
	-> The add_reference method allows the creation of an appropriately named column.
	
	:-	class AddReferences < ActiveRecord::Migration[7.0]
		  def change
		    add_reference :users, :role, foreign_key: true           #add_reference also can be used as add_belongs_to
		    add_belongs_to :taggings, :taggable, polymorphic: true
		    remove_reference :products, :user, foreign_key           #remove the reference from the model
		  end
		end
		
		
	g). Foreign Keys
	
	:-	 class ForeignKey < ActiveRecord::Migration[7.0]
		  def change
		    add_foreign_key :products, :categories, column: :id      #adding foreign key
		    remove_foreign_key :products, column: :id		       #removing foreign key
		  end
		end
		
		# let Active Record figure out the column name
		remove_foreign_key :accounts, :branches

		# remove foreign key for a specific column
		remove_foreign_key :accounts, column: :owner_id
		
	h). When Helpers aren't Enough
	-> Sometimes the helpers provided by Active Record might not be enough to perform certain database operations, 
	-> such as complex joins, subqueries, or custom SQL queries. 
	-> In such cases, we can use the execute method to execute arbitrary SQL statements directly on the database.
	
		:-      class Helper < ActiveRecord::Migration[7.0]
			  def change
			    Product.connection.execute("UPDATE products SET price = 1 WHERE 1=1")    #making connection with product model
			  end										#and execute inner query directly.
			end
			
			
	i). Using the change Method
	
		:-	class ChangeMethods < ActiveRecord::Migration[7.0]
			  def change
			    change_column_comment :products, :grade, from: "grade for product", to: "providing grade for product"
			    change_column_default :products, :price, from: 1, to: 9 
			    change_column_null :products, :p_name, false
			    create_table :manager do |t|
			      t.string :name
			      t.string :email
			      t.timestamps
			    end
			    disable_extension "pgcrypto"			#desable the pgcrypto extension in PostgreSQL
			    drop_join_table :products, :users
			    enable_extension "pgcrypto"			#enable the pgcrypto extension in PostgreSQL
			    remove_column :products, :p_name, :string
			    remove_index :categorization, name: "index_categorization_on_category_id"
			    remove_timestamps :products
			  end
			  
	NOTE :-   rename_index :users, :index_users_on_email, :index_users_on_email_address
		  rename_table :old_table_name, :new_table_name
end
