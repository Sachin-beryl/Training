------------------------------------------------------ Active Record Associations -----------------------------------------------------

 -> In Rails, an association is a connection between two Active Record models.
 
 ****************************** NOTE :- using below two association, to make one to many relation. ************************************
 
 (**) before adding association :-
 
 	1). first make model and enter data for that table.
 	
 	    :- rails g model book name book_type   #if we not specify the type opf column it will take string.
 	    
 	    -> data enter in book table
 	    	:- Book.create([{name: "The Hobbit ", book_type: "Fantasy"},{name: "And Then There Were None", book_type: "Mystery"}
 	    	,{name: "The Little Prince", book_type: "Adventure"},{name: "A Tale Of Two Cities", book_type: "fiction"}])

 (**) After adding association
 
	2). Now add association :-
 	    
	    :- rails g model author name book:references    # it will automatically generate belongs_to association in author.
	    
	    -> check in app/model/author.rb
	    	:-     class Author < ApplicationRecord
			  belongs_to :book                  # belongs_to always use singular model name.
			end
		
	    -> create manual has_many association in book.rb
	   	:-	class Book < ApplicationRecord
			  has_many :authors		     # has_many always use plural model name.
			end
			
	     a). now enter the data for author table.
	     
	     	:- Author.create([{name: "JRR Tolkien", book_id: 2},{name: "Agatha Christie", book_id: 3},{name: "Antoine de Saint
	     	-ExupÃ©ry", book_id: 4},{name: "Charles Dickens", book_id: 5},{name: "Charles Dickens", book_id: 3}])


  practise on console :-
  
  	*). save book one row into variable.
  		:- b1 = Book.find(3)
  		
  	*). for check author detail related to 3rd id book. 
  		:- b1.authors
  		
  output:- showing one book have two author  (one-2-many)
  
        Author Load (0.5ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = $1  [["book_id", 3]]
	=>                                                              
	[#<Author:0x00007f2c814e91c0                              
	  id: 3,                                                  
	  name: "Agatha Christie",                                
	  book_id: 3,                                             
	  created_at: Thu, 30 Mar 2023 09:03:00.249358000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 09:03:00.249358000 UTC +00:00>,
	 #<Author:0x00007f2c814e8fe0                              
	  id: 6,                                                  
	  name: "Charles Dickens",                                
	  book_id: 3,                                             
	  created_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 09:03:00.262260000 UTC +00:00>] 
 
----------------------------------------------------------------------------------------------------------------------------------
 								has_one Association
 								 
 -> A has_one association indicates that one other model has a reference to this model. 
 -> That model can be fetched through this association.
 
 	*). Making publisher migration for has_one.
 	
 		:-     class CreatePublishers < ActiveRecord::Migration[7.0]
			  def change
			    create_table :publishers do |t|
			      t.string :name
			      t.references :book, null: false, foreign_key: true      #when we migarte,then automatic reference is created. 
			      t.timestamps
			    end
			  end
			end
			
	*). now manual add has_one in book to make book have one publisher.
	
		:-     class Book < ApplicationRecord
			  has_many :authors
			  has_one :publisher
			end
			
		:-     class Publisher < ApplicationRecord
			  belongs_to :book
			end
			
 practise on console :-
 
 	3.2.1 :006 > b1 = Book.first
                   
        output :-
                                        
	   3.2.1 :007 > b1.publisher
	   
			  Publisher Load (0.3ms)  SELECT "publishers".* FROM "publishers" WHERE "publishers"."book_id" = $1 LIMIT $2  
			  [["book_id", 1], ["LIMIT", 1]]
			 =>                                                              
			#<Publisher:0x00007fa824e17818                                   
			 id: 1,                                                          
			 name: "Arihant Books",                                          
			 book_id: 1,                                                     
			 created_at: Thu, 30 Mar 2023 10:22:22.746515000 UTC +00:00,     
			 updated_at: Thu, 30 Mar 2023 10:22:22.746515000 UTC +00:00>     

-----------------------------------------------------------------------------------------------------------------------------------
							has_many :through Association
							
 -> A has_many :through association is often used to set up a many-to-many connection with another model. 
 -> This association indicates that the declaring model can be matched with zero or more instances of 
    another model by proceeding through a third model.
			
 	*). for has_many :through we make two model, first = category and second = book_category (this is used for through as common)
 	
 		-> category model
 		 	:- rails g model category name
 		 	
 	        -> book_category model reference with book and category model.
 			:- rails g model book_category book:references category:references
 			
	 		after migration:-	class CreateBookCategories < ActiveRecord::Migration[7.0]
						  def change
						    create_table :book_categories do |t|
						      t.references :book, null: false, foreign_key: true
						      t.references :category, null: false, foreign_key: true
						      t.timestamps
						    end
						  end
						end
						
practise on console :-
  
  a) call many category related to one book.
  
  	3.2.1 :024 > b2.categories
 
	output:-
	
	  id: 2,
	  name: "Contemporary",
	  created_at: Thu, 30 Mar 2023 11:39:51.851053000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 11:39:51.851053000 UTC +00:00>,
	 #<Category:0x00007fa8242eb548
	  id: 6,
	  name: "Mystery",
	  created_at: Thu, 30 Mar 2023 11:39:51.864012000 UTC +00:00,
	  updated_at: Thu, 30 Mar 2023 11:39:51.864012000 UTC +00:00>] 
	  
	  
   b) call many book related to one category.
   
	3.2.1 :025 > cate = Category.find(5)
	3.2.1 :026 > cate.books
	  
	output:- 
                                          
	  id: 4,                                                               
	  name: "The Little Prince",                                           
	  book_type: "Adventure",                                              
	  created_at: Thu, 30 Mar 2023 08:54:11.350053000 UTC +00:00,          
	  updated_at: Thu, 30 Mar 2023 08:54:11.350053000 UTC +00:00>,         
	 #<Book:0x00007fa824336a48                                             
	  id: 5,                                                          
	  name: "A Tale Of Two Cities",                                   
	  book_type: "fiction",                                           
	  created_at: Thu, 30 Mar 2023 08:54:11.352993000 UTC +00:00,     
	  updated_at: Thu, 30 Mar 2023 08:54:11.352993000 UTC +00:00>]    

------------------------------------------------------------------------------------------------------------------------------------
							has_one :through Association
							
-> A has_one :through association sets up a one-to-one connection with another model. 
-> This association indicates that the declaring model can be matched with one instance of another model by proceeding through a third model.

-> for has_one :through association we will make book record model and record model.

	:- Record model association.
	   
	       class Record < ApplicationRecord
		  belongs_to :book_record
		end

	:- Book model association.
	
	  	has_one :book_record
  		has_one :record, through: :book_record
  		
  	:- BookRecord model association.
  	
  		class BookRecord < ApplicationRecord
		  belongs_to :book
		  has_one :record
		end
		
		
practise on console :-

	3.2.1 :015 > book = Book.find(2)
	3.2.1 :017 > book.record

	output :-                                      
	 id: 1,                                                           
	 borrowed: true,                                                  
	 book_record_id: 2,                                               
	 created_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00,      
	 updated_at: Thu, 30 Mar 2023 13:31:35.263745000 UTC +00:00>      

-----------------------------------------------------------------------------------------------------------------------------------
						  has_and_belongs_to_many Association
						  
-> A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model. 
-> This association indicates that each instance of the declaring model refers to zero or more instances of another model.

	:- Borrower model
	
		class Borrower < ApplicationRecord
		  has_and_belongs_to_many :books
		end
		
	:- Book model
	
		class Book < ApplicationRecord
		  has_and_belongs_to_many :borrowers
		end
		
	:- create join table of borrower and book
	
		class CreateJoinTableBooksBorrowers < ActiveRecord::Migration[7.0]
		  def change
		    create_join_table :books, :borrowers
		  end
		end
		
practise on console :-

NOTE :- we have to enter data like below because we haven,t create a model to store data, we only made a table(books_borrowers).
	which don,t have its own id, it only store ids of book and borrower model. when we create data ike below.
	
	-> books_borrowers is not a model so we can,t enter data as we do with models.(main reason)
	
	3.2.1 :041 > b1.books << Book.where(id:2)      #enter book detail in borrower
	3.2.1 :042 > b1.books
	
	output:-                                            
	  id: 2,                                                                
	  name: "The Hobbit ",                                                  
	  book_type: "Fantasy",                                                 
	  created_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00,           
	  updated_at: Thu, 30 Mar 2023 08:54:11.342365000 UTC +00:00>]   
	  
----------------------------------------------------------------------------------------------------------------------------------

 a). Choosing Between belongs_to and has_one:- (combination of both make one 2 one relation)
 
	 -> Use "belongs_to" when the child model is dependent on the parent model and cannot exist without it, 
	 -> Use "has_one" when the parent model has a single associated model that is not dependent on it and can exist independently.
 
 b). Choosing Between has_many :through and has_and_belongs_to_many :-
 -> Rails offers two different ways to declare a many-to-many relationship between models. 
 
 	-> Use has_many :through when the many-to-many relationship requires an intermediate model with its own attributes.s
 		eg:- if date required to borrow a book in library.
 	
 	-> Use has_and_belongs_to_many when the many-to-many relationship is simpler and does not require an intermediate model 
 		but needs an intermediate table.
 		
       NOTE :- Use has_many :through if you need validations, callbacks, or extra attributes on the join model.
       
------------------------------------------------------------------------------------------------------------------------------------
						      Polymorphic Associations
						
 -> A slightly more advanced twist on associations is the polymorphic association. With polymorphic associations, 
 -> a model can belong to more than one other model, on a single association.
 
 -> By using polymorphic association we will make feedbacks on books and authors.
 
 	a). feedback model creation.
 	
	 	class CreateFeedbacks < ActiveRecord::Migration[7.0]
		  def change
		    create_table :feedbacks do |t|
		      t.text :content
		      t.references :feedbackable, polymorphic: true
		      t.timestamps
		    end
		  end
		end
		
	b). Add this in both book.rb and author.rb
	
		has_many :feedbacks, as: :feedbackable
		
practise on console:-
 
 	:- create feedback for book
 	
 		3.2.1 :049 >  book = Book.first           
		3.2.1 :050 > book.feedbacks.create(content: 'This book is great!')
		
		output:-                                
		  id: 2,                                                          
		  content: "interesting book",                                    
		  feedbackable_type: "Book",                                      
		  feedbackable_id: 3,                                             
		  created_at: Fri, 31 Mar 2023 09:19:20.775789000 UTC +00:00,   
		  updated_at: Fri, 31 Mar 2023 09:19:20.775789000 UTC +00:00>]  
 
 	:- create feedback for author
 	
 		3.2.1 :061 > auth = Author.first
		3.2.1 :063 > auth.feedbacks.create(content: 'i like your book harry potter')
                        
               output:-                                              
		 id: 3,                                                                                             
		 content: "i like your book harry potter",                                                          
		 feedbackable_type: "Author",                                                                       
		 feedbackable_id: 1,                                                                                
		 created_at: Fri, 31 Mar 2023 09:21:13.518616000 UTC +00:00,                                        
		 updated_at: Fri, 31 Mar 2023 09:21:13.518616000 UTC +00:00>     
		 
-----------------------------------------------------------------------------------------------------------------------------------
							        Self Joins
							        
-> In designing a data model, you will sometimes find a model that should have a relation to itself.   
-> For self join we use section model to separate different book.

	select * from sections;
	 id |    name     | parent_id |         created_at         |         updated_at         
	----+-------------+-----------+----------------------------+----------------------------
	  1 | Library     |           | 2023-03-31 10:52:49.937362 | 2023-03-31 10:52:49.937362
	  2 | Fiction     |         1 | 2023-03-31 10:52:50.000949 | 2023-03-31 10:52:50.000949
	  3 | Non-fiction |         1 | 2023-03-31 10:52:50.065104 | 2023-03-31 10:52:50.065104
	  4 | Mystery     |         2 | 2023-03-31 10:52:50.098923 | 2023-03-31 10:52:50.098923
	  5 | Romance     |         2 | 2023-03-31 10:52:50.160441 | 2023-03-31 10:52:50.160441
	  6 | Biography   |         3 | 2023-03-31 10:52:50.230188 | 2023-03-31 10:52:50.230188
	  7 | History     |         3 | 2023-03-31 10:52:50.235257 | 2023-03-31 10:52:50.235257


	:- create section model
	
		class CreateSections < ActiveRecord::Migration[7.0]
		  def change
		    create_table :sections do |t|
		      t.string :name
		      t.integer :parent_id
		      t.timestamps
		    end
		  end
		  
	:- Add association in section model
	
		class Section < ApplicationRecord
		  belongs_to :parent, class_name: 'Section', optional: true
		  has_many :children, class_name: 'Section', foreign_key: 'parent_id'
		end
		end   
	 
practise on console:-

	a).  3.2.1 :111 > section.children
  
  		output:-
  		
		  id: 4,
		  name: "Mystery",
		  parent_id: 2,
		  created_at: Fri, 31 Mar 2023 10:52:50.098923000 UTC +00:00,
		  updated_at: Fri, 31 Mar 2023 10:52:50.098923000 UTC +00:00>,
		
		  id: 5,
		  name: "Romance",
		  parent_id: 2,
		  created_at: Fri, 31 Mar 2023 10:52:50.160441000 UTC +00:00,
		  updated_at: Fri, 31 Mar 2023 10:52:50.160441000 UTC +00:00>] 
		  
	b).  
		3.2.1 :112 > section = Section.find_by(name: 'Mystery')
		3.2.1 :113 > section.parent
		
	        output:-
	                            
		 id: 2,                                                        
		 name: "Fiction",                                              
		 parent_id: 1,                                                 
		 created_at: Fri, 31 Mar 2023 10:52:50.000949000 UTC +00:00,   
		 updated_at: Fri, 31 Mar 2023 10:52:50.000949000 UTC +00:00>   

----------------------------------------------------------------------------------------------------------------------------------
							Tips, Tricks, and Warnings
							
 1). Controlling Caching:-
 
  -> if you want to avoid caching or change the caching behavior, 
     you can use the :touch option to force the cache to be updated whenever the associated object is updated.
     
	eg:- if you have a Post model with a belongs_to :user association, 
	     you can add :touch => true to the association to ensure that the User model's cache is updated whenever a Post is updated.
	     
	     :- class Post < ApplicationRecord
		  belongs_to :user, :touch => true
		end
		
 2). Avoiding name collisions:-
 
 -> When defining associations, make sure to choose unique names for the association methods to avoid name collisions 
    with other methods or attributes in your models.
    
	eg:- if you have a User model with a has_many :posts association, you can use a different name for the association method:

	     :- class User < ApplicationRecord
		  has_many :published_posts, class_name: "Post"
		end
		
 3). Updating the Schema:-
 
 	a). Creating Foreign Keys for belongs_to Associations:-
 	
	-> When you declare a belongs_to association, you need to create foreign keys as appropriate.
	eg:-
		class Book < ApplicationRecord
		  belongs_to :author
		end

		class CreateBooks < ActiveRecord::Migration[7.0]
		  def change
		    create_table :books do |t|
		      t.datetime   :published_at
		      t.string     :book_number
		      t.references :author
		    end
		  end
		end
		
	b). Creating Join Tables for has_and_belongs_to_many Associations:-
	
	-> If you create a has_and_belongs_to_many association, you need to explicitly create the joining table.
	eg:-
		class Assembly < ApplicationRecord
		  has_and_belongs_to_many :parts
		end

		class Part < ApplicationRecord
		  has_and_belongs_to_many :assemblies
		end
		
	       :- need to be backed up by a migration to create the assemblies_parts table. 
	  note :- This table should be created without a primary key:    (also we can use id: false to create table without id)
	  
	  	class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
		  def change
		    create_join_table :assemblies, :parts do |t|
		      t.index :assembly_id
		      t.index :part_id
		    end
		  end
		end
		
 4). Controlling Association Scope :-
 
 -> By default, associations look for objects only within the current module's scope. 
    This can be important when you declare Active Record models within a module.
    
    note :- it is important that both the Supplier and the Account class are defined within the same scope.
    	eg:- 
	    	module MyApplication
		  module Business
		    class Supplier < ApplicationRecord
		      has_one :account
		    end

		    class Account < ApplicationRecord
		      belongs_to :supplier
		    end
		  end
		end
		
 5). Bi-directional Associations :-
 
 -> It's normal for associations to work in two directions, requiring declaration on two different models:
 
 	eg:- 
		class Author < ApplicationRecord
		  has_many :books
		end

		class Book < ApplicationRecord
		  belongs_to :author
		end

 -> Active Record will attempt to automatically identify that these two models share a bi-directional association based on 
    the association name. In this way, Active Record will only load one copy of the Author object, 
    making your application more efficient and preventing inconsistent data.
    
-----------------------------------------------------------------------------------------------------------------------------------
						   Detailed Association Reference
						   
 -> The following sections give the details of each type of association, including the methods that they add and 
    the options that you can use when declaring an association.
    
   1). belongs_to Association Reference
   
     -> In database terms, the belongs_to association says that this model's table contains a column which represents 
        a reference to another table. This can be used to set up one-to-one or one-to-many relations, depending on the setup.
        
        a). Methods Added by belongs_to :-
		
	    *). association
	    
	    	eg:- book = Book.first
		     book.category #=> returns the associated Category object
		
	    *). association=(associate)
	    
	        eg:-   book = Book.first
			category = Category.find_by(name: "Science Fiction")
			book.category = category
	        
	    *). build_association(attributes = {})
	    
	    	eg:-    book = Book.first
			category = book.build_category(name: "Fantasy")
	    	
	    *). create_association(attributes = {})
	    
	    	eg:-	book = Book.first
			category = book.create_category(name: "Mystery")
			
	    *). create_association!(attributes = {})    #raise error when record is invalid.
	    
	    	eg:-	book = Book.first
			category = book.create_category!(name: "Thriller")
			
	    *). reload_association        # This method reloads the associated Category object from the database
	    
	    	eg:-	book = Book.first
			book.category #=> returns the associated Category object
			
			# Suppose the category name is changed in another process:
			
			Category.first.update(name: "New Name")
			book.reload_category #=> returns the updated Category object
			
	    *). association_changed?     #return true if association get modified
	    
	    	eg:-	book = Book.first
			book.category #=> returns the associated Category object
			book.category.name #=> "Science Fiction"
			book.category.name = "New Name"
			book.category_changed? #=> true
			
	    *). association_previously_changed?    #returns true if the association change after the last time object get saved.
		   
		eg:-	book = Book.first
			book.category #=> returns the associated Category object
			book.update(title: "New Title")
			book.category_previously_changed? #=> true
			
	
