------------------------------------------------------------INTRODUCTION-----------------------------------------------------------------

 1). Ruby is a scripting language designed by Yukihiro Matsumoto, also known as Matz.
 2). It runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX.
 3). Ruby is a pure object-oriented programming language.
 4). Ruby is a general-purpose, interpreted programming language.
 5). Ruby is a server-side scripting language similar to Python and PERL.
 6). Ruby can be used to write Common Gateway Interface (CGI) scripts.
 CGI -> a simple protocol for passing an HTTP request from a web server to a standalone program, and returning the output to the web browser
 
 7). Ruby can be embedded into Hypertext Markup Language (HTML).

------------------------------------------------------------Ruby Installation------------------------------------------------------------

 1). Update the system repositories with:
	sudo apt update

 2). Use the following command to install Ruby:
	sudo apt install ruby-full
	
 3). Type 'y' in terminal to give permission to download and install ruby.
 
 
 4). install rvm in linux :-
 
 	a). install GPG keys used to verify installation package:

key :- gpg --keyserver keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
 
 	b). Install RVM stable with ruby (development version):

		-> \curl -sSL https://get.rvm.io | bash -s stable --ruby
		
 5). install ruby using rvm:-
 	-> rvm install 3.2.1
 	
 6). RVM Configuration :-
 	-> Defaults = RVM has a set of defaults recorded in the file.
 	
		$rvm_config_path/db
 	
 	-> Overriding Default Settings
		RVM also has a directory for user overrides located in $rvm_path/user/. In order to override RVM's default settings, 			place the appropriate key=value into the db file of that folder

		$rvm_path/user/db

 
                                    ----------IF ALREADY PRESENT UPDATE THE VERSION OF RUBY----------
                      
                a). check version on rvm(ruby version manager) in terminal.
                	rvm -v
                	
                b). list the version of ruby using rvm.
                	rvm list known
                	
                c). Now install the latest version of ruby.
                	rvm install 3.2.1(version number)
                	
                d). check for ruby version.
                	ruby -v
                	
                e). check ruby version present on system.
                	rvm list
                	
                f). switch between ruby versions.
                	rvm use (version_number_present_on_system)
                	
                g). set default version of ruby.
                	rvm 3.2.1 --default
                	

------------------------------------------------------------PLATFORMS TO RUN RUBY--------------------------------------------------------

 1). VIM (Vi IMproved) is a very simple text editor.
 
 2). Interactive Ruby (IRb) :- 
 	a). Interactive Ruby (IRb) provides a shell for experimentation. Within the IRb shell, you can immediately view expression results, line by line.
 	b). Just type irb at your command prompt and an Interactive Ruby Session will start.
 		
 		eg:- beryl@beryl-HP-Pavilion-Notebook:~$ irb
			3.2.1 :001 > puts "sachin"
			sachin
			 => nil                                      
			3.2.1 :003 >   out = "Hello"
			3.2.1 :004 >   puts out
			3.2.1 :005 > end
			 => :hello 
	
	c). Exit the ruby terminal type "quit".
	
 3). VScode :- install vscode , install extensions in vscode related to ruby.
 
------------------------------------------------------------Ruby Syntax-----------------------------------------------------------------

 1). All ruby files will have extension .rb
 
 2). To print the output in ruby :-
 
 	a. puts "Hello, Ruby!";        # it will provide new line by default.
 	b. print "Hello, Ruby!";       # semicolon is not mendatory.
 	
 3). Whitespace in Ruby Program :-
 	-> Whitespace characters such as spaces and tabs are generally ignored in Ruby code, except when they appear in strings.
 	
 	eg :-   a + b is interpreted as a+b ( Here a is a local variable)
		a  +b is interpreted as a(+b) ( Here a is a method call)
		
 4). Ruby Identifiers :-
       -> Identifiers are names of variables, constants, and methods. Ruby identifiers are case sensitive. 
       -> It means Ram and RAM are two different identifiers in Ruby.
       
 5). Reserved Words :-
       -> The following list shows the reserved words in Ruby. These reserved words may not be used as constant or variable names. 
       -> They can, however, be used as method names.

	BEGIN		do	next	then
	END		else	nil	true
	alias		elsif	not	undef
	and		end	or	unless
	begin		ensure	redo	until
	break		false	rescue	when
	case		for	retry	while
	class		if	return	while
	def		in	self	__FILE__
	defined?	module	super	__LINE__
       
 6). Here Document in Ruby :-
 
	-> "Here Document" refers to build strings from multiple lines. 
	-> Following a << you can specify a string or an identifier to terminate the string literal, and all lines following the current line up to the terminator are the value of the string.

	-> If the terminator is quoted, the type of quotes determines the type of the line-oriented string literal. 
	-> Notice there must be no space between << and the terminator.
       
        eg :- a). print <<EOF
		   This is the first way of creating
		   here document ie. multiple line string.
		  EOF

	      b). print <<"EOF";                # same as above
		   This is the second way of creating
		   here document ie. multiple line string.
		  EOF

	      c). print <<`EOC`                 # execute commands
			echo hi there
			echo lo there
		  EOC

	      d). print <<"foo", <<"bar"  # you can stack them
			I said foo.
		  foo
			I said bar.
		  bar
		  
 7). Ruby BEGIN Statement :- Declares code to be called before the program is run.
	
	Syntax :- 
		BEGIN {
	   	   code
		}
	
	eg :- 
	code :-   puts "main code"
		  BEGIN{
		     puts "priority code"
		  }

	output :- priority code
		  main code

 8). Ruby END Statement :-
	Syntax :- 
		END {
		   code
		}
		
	eg :- 
	 code :- puts "main code"
		END{
		    puts "Always run at the end of code"
		}
		BEGIN{
		    puts "priority code"
		}
		
	output :- priority code
		  main code
		  Always run at the end of code
		  
 9). Ruby Comments :-
	-> A comment hides a line, part of a line, or several lines from the Ruby interpreter. 
	-> You can use the hash character (#) at the beginning of a line 

		eg :- # I am a comment. Just ignore me.
		
		   :- =begin
		      This is a comment.
		      This is a comment, too.
		      This is a comment, too.
		      I said that already.
		      =end
		
--------------------------------------------------------Classes and Objects--------------------------------------------------------------

 -> features of the object-oriented programming language include −

	Data Encapsulation
	Data Abstraction
	Polymorphism
	Inheritance
	
 -> An object-oriented program involves classes and objects. 
 -> A class is the blueprint from which individual objects are created.
 
 1). Defining a Class in Ruby :-
 	-> A class in Ruby always starts with the keyword class followed by the name of the class. 
 	-> The name should always be in initial capitals.

	syntax :- class Customer
		  end
	        	    
 2). Creating Objects in Ruby using new Method :-
 	
 	-> Objects are instances of the class.
 	-> The new method belongs to the class methods.
 	
 	eg :- cust1 = Customer. new
	      cust2 = Customer. new

 3). Member Functions in Ruby Class :-
 
 	-> functions are called methods. 
 	-> Each method in a class starts with the keyword def followed by the method name.
	-> The method name always preferred in lowercase letters. 
	-> End a method in Ruby by using the keyword end.
	
	eg:- class Sample
		  def hello
		     puts "Hello Ruby!"
		  end
	     end
 
 	     # Now using above class to create objects
	     object = Sample. new
	     object.hello
	     
 4). Ruby Constants :-
	-> Constants begin with an uppercase letter. 
	-> Constants defined within a class or module can be accessed from within that class or module. 
	-> And those defined outside a class or module can be accessed globally.
	
		eg :- VAR1 = 100
 NOTE:-	   :- puts "Value of first Constant is #{VAR1}"

-------------------------------------------------------------VARIABLES-------------------------------------------------------------------

 1). Local Variables    -> Local variables begin with a lowercase letter or _.

 2). Instance Variables −> Instance variables are available across methods for any particular instance or object. 
			-> Instance variables are preceded by the at sign (@) followed by the variable name.
			    
			    	eg:- @cust_id = id
	NOTE:-		    	  :- puts "Customer id #@cust_id"    

 3). Class Variables    −> Class variables are available across different objects.
			-> They are preceded by the sign @@ and are followed by the variable name.
			    
			    	eg:- class Customer
   				        @@no_of_customers = 0
				     end

 4). Global Variables   −> Class variables are not available across classes. 
        	       -> If you want to have a single variable, which is available across classes, 
        	       -> you need to define a global variable. 
        	       -> The global variables are always preceded by the dollar sign ($).
        	    
	        	    	eg :- $global_variable = 10

 5). Ruby Pseudo-Variables :-
  
  -> They are special variables that have the appearance of local variables but behave like constants.
  -> You cannot assign any value to these variables.

	a). self     − The receiver object of the current method.
	b). true     − Value representing true.
	c). false    − Value representing false.
	d). nil      − Value representing undefined.
	e). __FILE__ − The name of the current source file.
	f). __LINE__ − The current line number in the source file.
	
 6). Ruby Basic Literals :-
 
 	a). Integer Numbers  :- range from -2^30 to (2^30)-1 or -2^62 to (2^62)-1.
 	b). Floating Numbers :- Ruby supports floating numbers. They are also numbers but with decimals.
 	c). String Literals  :- Ruby strings are simply sequences of 8-bit bytes and they are objects of class String. 
 			      :- Double-quoted strings allow substitution and backslash notation 
 			      :- but single-quoted strings don't allow substitution and allow backslash notation only for \\ and \'
 			      
 		eg :-   puts 'escape using "\\"';
			puts 'That\'s right';
			
			output :-
				escape using "\"
				That's right
			 	
 NOTE IMP :- You can substitute the value of any Ruby expression into a string using the sequence #{ expr }.
 
 7). Ruby Arrays :-
 
 -> Literals of Ruby Array are created by placing a comma-separated series of object references between the square brackets. 
 -> A trailing comma is ignored.

   eg :-
	ary = [  "fred", 10, 3.14, "This is a string", "last element", ]
	ary.each do |i|
	   puts i
	end

   output :-
	fred
	10
	3.14
	This is a string
	last element
	
 8). Ruby Hashes
  -> A literal Ruby Hash is created by placing a list of key/value pairs between braces, with either a comma or the sequence => between the key and the value. 
  -> A trailing comma is ignored.

	eg :- 
		hsh = colors = { "red" => 0xf00, "green" => 0x0f0, "blue" => 0x00f }
		hsh.each do |key, value|
		   print key, " is ", value, "\n"
		end

	output :-
		red is 3840
		green is 240
		blue is 15

 9). Ruby Ranges
  -> A range (1..5) means it includes 1, 2, 3, 4, 5 values 
  -> A range (1...5) means it includes 1, 2, 3, 4 values.
  
	eg:-
		(10..15).each do |n| 
		   print n, ' ' 
		end
		
	output :-
		10 11 12 13 14 15
		
----------------------------------------------------------Ruby - Operators--------------------------------------------------------------

 1). Arithmetic Operators :- +,-,/,%,*,**(power).
 
 2). Arithmetic Operators :- ==,!=,>,<,<=,>=,

	a). Combined comparison operator(<=>)
		-> Returns 0 if first operand equals second                 5<=>5    return 0
		-> 1 if first operand is greater than the second            5<=>2    return 1
		-> -1 if first operand is less than the second.             2<=>5    return -1
	
	b). ===  -> Used to test equality within a when clause of a case statement.	
			
		eg:- (1...10) === 5 returns true.

       c). (.eql?) -> True if the receiver and argument have both the same type and equal values.	
       
       	eg:- 1 == 1.0 returns true, but 1.eql?(1.0) is false.

       d). equal?  -> True if the receiver and argument have the same object id.	
       
       	eg:- if aObj is duplicate of bObj then aObj == bObj is true
       	     a.equal?bObj is false but a.equal?aObj is true.
		
 3). Assignment Operators :- =,+=,-=,*=,/=,%=,**=
 
 4). Parallel Assignment :-
 
 	eg :- 1. a, b, c = 10, 20, 30
 	      2. for swap -> a, b = b, c
 	      
 5). Bitwise Operators :- &,|,^,~,<<,>>
 
 6). Logical Operators :- and,or,&&,||,!,not
 
 7). Ternary Operator :- (?:)
 
 	syntax :-If Condition is true ? Then value X : Otherwise value Y
 	
 8). defined? Operators :-
  
 -> defined? is a special operator that takes the form of a method call to determine whether or not the passed expression is defined.
 
 	eg :- defined? variable      # True if variable is initialized
 	   :- defined? method_call   # True if a method is defined
 	   :- defined? super         # True if a method exists that can be called with super user
 	   :- defined? yield         # True if a code block has been passed

 9). Double Colon "::" Operators :-
 
  -> The :: is a unary operator that allows: constants, instance methods and class methods defined within a class or module, to be  	accessed from anywhere outside the class or module.
  
  -> You need to just prefix the :: Const_name with an expression that returns the appropriate class or module object.
  
  NOTE :- Remember in Ruby, classes and methods may be considered constants too.
  
  	eg :-
  		CONST = ' out there'
		class Inside_one
		   CONST = proc {' in there'}
		   def where_is_my_CONST
		      ::CONST + ' inside one'
		   end
		end
		class Inside_two
		   CONST = ' inside two'
		   def where_is_my_CONST
		      CONST
		   end
		end
		puts Inside_one.new.where_is_my_CONST
		puts Inside_two.new.where_is_my_CONST
		puts Object::CONST + Inside_two::CONST
		puts Inside_two::CONST + CONST
		puts Inside_one::CONST
		puts Inside_one::CONST.call + Inside_two::CONST

-----------------------------------------------------------------IF ELSE---------------------------------------------------------------

 1). if...else Statement
	Syntax :-
		if conditional [then]
		   code...
		[elsif conditional [then]
		   code...]...
		[else
		   code...]
		end

	eg :-
		number = 1
		if number > 2
		    puts "number is greater then two"
		elsif number <= 2 and number != 0
		    puts "The number is 1"
		else
		    puts "Invalid number"
		end

 2). if modifier
	Syntax :-
		code if condition       (Executes code if the conditional is true.)

	eg:-
		$debug = 1
		print "debug\n" if $debug
	
	output :-
		debug
		
 3). unless Statement
 	-> Executes code if conditional is false.
 
	Syntax :-
		unless conditional [then]
		   code
		[else
		   code ]
		end
		
	eg :-
		number = 1;
		unless number >= 2
		    puts "number equals to 1"
		else
		    puts "number is greater than 2"
		end
			
	output:-
		number equals to 1
		
 4). unless modifier
 	syntax :- 
 		code unless condition
 	eg :-
 		$var = false
		print "3 -- Value is set\n" unless $var
		
 5). case Statement
 	syntax :-
	 	case expr0
		when expr1, expr2
		   stmt1
		when expr3, expr4
		   stmt2
		else
		   stmt3
		end

	eg:-
		$age =  5
		case $age
		when 0 .. 2
		   puts "baby"
		when 3 .. 6
		   puts "little child"
		when 7 .. 12
		   puts "child"
		when 13 .. 18
		   puts "youth"
		else
		   puts "adult"
		end

	output :-
		little child

---------------------------------------------------------------Loops-------------------------------------------------------------------

 1). while Statement
	Syntax :-
		while conditional [do]
		   code
		end
		
	eg 1 :- 
		number = 1;
		while number < 5 do
		    puts ("something #{number}")
		    number += 1
		end
	
	eg 2 :- 3.2.1 :071 >	def sum
		3.2.1 :071 >   num = 1
		3.2.1 :072 >   a = 5
		3.2.1 :073 >   b = 10
		3.2.1 :074 >   while num < 6 do
		3.2.1 :075 >     puts ("sum of a and b is #{a+b}")
		3.2.1 :076 >     num += 1
		3.2.1 :077 >   end
		3.2.1 :078 > end
		 => :sum 
		 
	output :-
		3.2.1 :079 > sum
		sum of a and b is 15
		sum of a and b is 15                                                 
		sum of a and b is 15                                                 
		sum of a and b is 15                                                 
		sum of a and b is 15   
		
 2). while modifier
	Syntax :-
		code while condition

		OR

		begin 
		  code 
		end while conditional
		
	eg :-
		number = 1;
		begin 
		    puts "something #{number}"
		    number += 1
		end while number < 6

 3). until Statement
 	syntax :-
		until conditional [do]
		   code
		end
		
	eg :-
		number = 1
		until number > 5 do
		    puts "number is #{number}"
		    number += 1
		end
				
 4). until modifier
	Syntax :-
		code until conditional

		OR

		begin
		   code
		end until conditional
		
	eg :-
		number = 1
		begin
		    puts "number is #{number}"
		    number += 2
		end until number > 5

 5). for Statement
	Syntax :-
		for variable [, variable ...] in expression [do]
		   code
		end
	
	eg 1 :-
		number = 10
		for i in 1..5
		    print (number * i),"\n"
		end
		
	eg 2 :-
		3.2.1 :130 > def sub
		3.2.1 :131 >   num1 = 10
		3.2.1 :132 >   num2 = 20
		3.2.1 :133 >   for i in 1..5
		3.2.1 :134 >     num3 = num2 - num1
		3.2.1 :135 >     puts (num3)
		3.2.1 :136 >   end
		3.2.1 :137 > end
		 => :sub 
		 
	output :-
		3.2.1 :138 > sub
		10
		10                                      
		10                                      
		10                                      
		10                
		
	for each loop :- (0..5).each do |i|
			     puts "Value of local variable is #{i}"
		     	  end
		     	  
 6). break Statement
 	eg:-
 		for i in 0..5
		   if i > 2 then
		      break
		   end
		   puts "Value of local variable is #{i}"
		end
				     
 	output:-
 		Value of local variable is 0
		Value of local variable is 1
		Value of local variable is 2
		
 7). next Statement
 	eg:- 
 		for i in 0..5
		   if i < 2 then
		      next
		   end
		   puts "Value of local variable is #{i}"
		end

	output :-
		Value of local variable is 2
		Value of local variable is 3
		Value of local variable is 4
		Value of local variable is 5

 8). redo Statement 
 -> Restarts this iteration of the most internal loop, without checking loop condition.
 	eg:-
 		for i in 0..5
		   if i < 2 then
		      puts "Value of local variable is #{i}"
		      redo
		   end
		end
		
	output :-
		This will produce the following result and will go in an infinite loop −

		Value of local variable is 0
		Value of local variable is 0
		............................
				
 9). retry Statement
 -> If retry appears in rescue clause of begin expression, restart from the beginning of the begin body.

	syntax:-
		begin
		   do_something # exception raised
		rescue
		   # handles error
		   retry  # restart from beginning
		end

	   eg:-
		for i in 1..5
		   retry if some_condition # restart from i == 1
		end	
		
	     :- for i in 0..5
		   retry if i > 2
		puts "Value of local variable is #{i}"
		end
			
	output:-
		This will produce the following result and will go in an infinite loop −

		Value of local variable is 1
		Value of local variable is 2
		Value of local variable is 1
		Value of local variable is 2
		Value of local variable is 1
		Value of local variable is 2
		............................

-------------------------------------------------------------METHODS--------------------------------------------------------------------

 -> Ruby methods are very similar to functions in any other programming language. 
 -> Ruby methods are used to bundle one or more repeatable statements into a single unit.
 -> Method names should begin with a lowercase letter. 
 
 	syntax :-
	     1. def method_name 
		   expr..
		end

	     2. def method_name (var1, var2)
		   expr..
		end

	     3. def method_name (var1 = value1, var2 = value2)
		   expr..
		end

 1). return Statement :-
 
 -> The return statement in ruby is used to return one or more values from a Ruby Method.
 	syntax :-
		return [expr[`,' expr...]]

	eg :- 
		def return_method
		    a = 10
		    b = 15
		    c = 20

		    return a,b,c     #multiple return
		end

		ret = return_method  #saving method return into variable.
		puts ret	      # print the return using variable.
		
 2). Variable Number of Parameters :-
 -> Suppose you declare a method that takes two parameters. 
 -> whenever you call this method.
 -> you need to pass two parameters along with it.
 -> However, Ruby allows you to declare methods that work with a variable number of parameters.
 -> This means that this parameter can take in any number of variables.

	eg :-
		def sample(*a)
		    puts "The length of variable is #{a.length}"
		    for i in 0...a.length
			puts "The values are #{a[i]}"
		    end
		end

		sample(1,2,3)
		sample('ram','shiv')
		
	output :-
		The length of variable is 3
		The values are 1
		The values are 2
		The values are 3
		The length of variable is 2
		The values are ram
		The values are shiv

 3). Class Methods :- 
 -> When a method is defined outside of the class definition, the method is marked as private by default. 
 -> On the other hand, the methods defined in the class definition are marked as public by default. 
 -> The default visibility and the private mark of the methods can be changed by public or private of the Module.

 NOTE --->>>>Ruby gives you a way to access a method without instantiating a class.

	eg :- 
		class Sample
		    def test1
			puts "normal method"
		    end
		    def Sample.test2
			puts "class method"
		    end
		end

		Sample.test2     #call the method without making object of class.
		 	
	output :-
		class method
		
 4). alias Statement :-
 -> This gives alias to methods or global variables.       NOTE :- alias only for method and global variable.
 -> Aliases cannot be defined within the method body. 
 -> The alias of the method keeps the current definition of the method.
 -> Making aliases for the numbered global variables ($1, $2,...) is prohibited. 
 
	Syntax :-
		alias method-name method-name
		alias global-variable-name global-variable-name
	Example :-
		alias foo bar
		alias $MATCH $&
		Here we have defined foo alias for bar, and $MATCH is an alias for $&
		
 5). undef Statement :-
 -> This cancels the method definition. 
 -> An undef cannot appear in the method body.

	Syntax :-
		undef method-name

	eg :-
		undef bar   #To undefine a method called bar.
		
------------------------------------------------------------------------------------------------------------------------------------
								BLOCKS
								
 -> A block consists of chunks of code.
 -> You assign a name to a block.
 -> The code in the block is always enclosed within braces ({}).
 -> A block is always invoked from a function with the same name as that of the block. This means that if you have a block with the name test, then you use the function test to invoke this block.

 -> You invoke a block by using the yield statement.
 
 	example :- def yield_check
		    puts "outside block 1"
		    yield
		    puts "outside block 2"
		    yield							      # calling block using yield keyword
		   end

		   yield_check {puts "block code check using yield statement"}     #block


	output :-  outside block 1
		   block code check using yield statement
		   outside block 2
		   block code check using yield statement
		   
		   
 	a). pass parameters with the yield statement.
 		
 		def yield_check
		    puts "outside block 1"
		    yield 10,9                                                  # calling block using yield keyword with parameter
		    puts "outside block 2"
		    yield 3,8                                               # calling block using yield keyword with parameter
		end

		yield_check {|a,b| puts "block code check using yield statement #{a} #{b}"} #block

	output :- 
		outside block 1
		block code check using yield statement 10 9
		outside block 2
		block code check using yield statement 3 8

	b). block as parameter using '&block'.
	
		def test(&block)
		   block.call         #calling block 
		end
		test { puts "Hello World!"}   #block
		
	c). begin and end block.
	
------------------------------------------------------------------------------------------------------------------------------------
								MODULES
								
 -> Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.
	1). Modules provide a namespace and prevent name clashes.
	2). Modules implement the mixin facility.
	
	Syntax :-
		module Identifier
		   statement1
		   statement2
		   ...........
		end
		
	3). Module constants are named just like class constants, with an initial uppercase letter. 
	4). The method definitions look similar, too: Module methods are defined just like class methods.
	
 -> require Statement :-
	1). The require statement is similar to the include statement of C and C++ and the import statement of Java. 
	2). If a third program wants to use any defined module, it can simply load the module files using the Ruby require statement −

	Syntax :-  require filename
	
 -> include Statement :-
	You can embed a module in a class. To embed a module in a class, you use the include statement in the class −

	Syntax :- include modulename
		
	
	eg :-
	step 1 :- make module file and module in it (module file extension is also .rb)
	
		module Module_tool
		    def hlo(name)
			puts "hlo #{name}"
		    end
		    def bye(name)
			puts "bye #{name}"
		    end
		end
		
	step 2 :- calling module feature in other file.
	
		require_relative "Module_tool.rb"   #relative is used to find module in same folder
		include Module_tool

		Module_tool.hlo('ram')	     #calling the module method .
	

	eg 2 :- for including module in class
	
	step 1 :- make module file support.rb
		
		module Week
		   FIRST_DAY = "Sunday"
		   def Week.weeks_in_month
		      puts "You have four weeks in a month"
		   end
		   def Week.weeks_in_year
		      puts "You have 52 weeks in a year"
		   end
		end
		
	step 2 :- calling module in class 
	
		$LOAD_PATH << '.'         #Ruby aware that included files must be searched in the current directory
		require "support"

		class Decade
		include Week
		   no_of_yrs = 10
		   def no_of_months
		      puts Week::FIRST_DAY
		      number = 10*12
		      puts number
		   end
		end
		d1 = Decade.new
		puts Week::FIRST_DAY
		Week.weeks_in_month
		Week.weeks_in_year
		d1.no_of_months
		
 -> MIXINS :-
 	1). eliminate the need for multiple inheritance.
 	2). Mixins give you a wonderfully controlled way of adding functionality to classes.
 	
 	eg :- 
 		module A
		    def a1
			puts "module A method a1"
		    end
		    def a2
			puts "module A method a2"
		    end
		 end
		 module B
		    def b1
			puts "module B method b1"
		    end
		    def b2
			puts "module B method b2"
		    end
		 end
		 
		 class Sample
		 include A
		 include B
		    def s1
			puts "class method call."
		    end
		 end
		 
		 samp = Sample.new
		 samp.a1
		 samp.a2
		 samp.b1
		 samp.b2
		 samp.s1

------------------------------------------------------------------------------------------------------------------------------------
								ARRAYS
								
 -> Ruby arrays are ordered, integer-indexed collections of any object. 
 -> Each element in an array is associated with and referred to by an index.
 -> Array indexing starts at 0.
 -> an index of -1 indicates the last element of the array and so on.
 -> Ruby arrays can hold objects such as String, Integer, Fixnum, Hash, Symbol, even other Array objects. 
 -> Ruby arrays grow automatically while adding elements to them.

	1). Creating Arrays using new keyword:-
		syntax :- names = Array.new

	2). Setting size of array :-
		syntax :- names = Array.new(20)

	3). assign a value to the array as follows :-

		eg :- names = Array.new(4, "mac")
		      puts "#{names}"

		output :- ["mac", "mac", "mac", "mac"]	
		
	4). use a block with new, populating each element with what the block evaluates to :-

		eg :- nums = Array.new(10) { |e| e = e * 2 }
		      puts "#{nums}"

		output :- [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]	

	5). Other ways of array creation :-
	
		eg :- nums = Array.[](1, 2, 3, 4,5)
		      nums = Array[1, 2, 3, 4,5]
		      
		      -> try_convert: Returns a new array created from a given object.
		      
		      		eg :-
		      			3.2.1 :012 > arr = [1, 2, 3]
					3.2.1 :013 > p Array.try_convert(arr)
					[1, 2, 3]
					 => [1, 2, 3]                                    
	      
	6). Using range :-
		
		eg :- digits = Array(0..9)
			puts "#{digits}"

		output :- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

	7). Built-in Methods :-
	
		a). digit.at(6)    #show digit at 6th index.
		b). arr.size       #provide size of array (count,length are similar to size)
		c). arr.pop        #remove last element from array
		d). arr.push       #add last element in array
		e). arr.shift      #add at begining
		f). arr.unshift    #remove at begining
		g). arr.sort       #sort in ascending order
		h). arr.reverse
		i). arr.include ? parameter  
		j). arr.flatten    #convert inner array into elements
		k). arr.compact    #remove null or nil values.
		l). arr.product    #convert each element in array.
		
	8). Convert into Array from other formats :-
	
		*). Enumerable#to_a: Converts an enumerable object (e.g. a range, a hash, or an enumerator) into an array. 
		
			eg :-   
				h = { "a" => 1, "b" => 2, "c" => 3 }
				p h.to_a # returns [["a", 1], ["b", 2], ["c", 3]]

		*). Hash#to_a: Converts a hash into an array of key-value pairs. 

			eg :- 
				h = { "a" => 1, "b" => 2, "c" => 3 }
				p h.to_a 
				# returns [["a", 1], ["b", 2], ["c", 3]]

		*). MatchData#to_a: Converts a MatchData object (which is returned by the String#match method) into an array containing the matched text and any capture groups.
			eg :- 
				s = "hello world"
				m = /world/.match(s)
				p m.to_a 
				# returns ["world"]

		*). NilClass#to_a: Returns an empty array. 
		
			eg :- 
				nil.to_a 
				# returns []
				
		*). Set#to_a : The Set#to_a method returns an array containing all elements in the set.
		
			eg :-
				require 'set'
				s = Set.new([1, 2, 3])
				s.to_a  
				# => [1, 2, 3]
		
		*). Struct#to_a : The Struct#to_a method returns an array containing the values of each member of the struct.
			
			eg :- 
				Person = Struct.new(:name, :age)
				p = Person.new("Alice", 30)
				p.to_a  
				# => ["Alice", 30]
				
	9). Accessing Elements :-
	
		eg :- 
			arr = [1,2,3,4,5,6,7]
			
			a). 3.2.1 :127 > arr[1,4]     # element in the range
			    => [2, 3, 4, 5] 
			    
			b). 3.2.1 :128 > arr[1..5]    # element in the range
			    => [2, 3, 4, 5, 6] 
			    
			c). 3.2.1 :129 > arr[1..-4]    # element in the range
			    => [2, 3, 4] 
			    
			d). 3.2.1 :132 > arr.at(4)   #element at specific position
			    => 5 
			 
			e). 3.2.1 :133 > arr.fetch(4)  #element at specific position
			    => 5 
			 
			f). 3.2.1 :134 > arr.first    #first element of array
			    => 1 
			 
			g). 3.2.1 :135 > arr.last     #last element of array
			    => 7 
			 
			h). 3.2.1 :136 > arr.take(3)   #first 3 element of array
			    => [1, 2, 3] 
			 
			i). 3.2.1 :137 > arr.drop(3)   #drop first 3 element of array
			    => [4, 5, 6, 7] 
			    
	10). Obtaining Information about an Array :-
	
		eg :-  
			3.2.1 :139 > arr
			 => [1, 2, 3, 4, 5, 6, 7] 
			 
			a). 3.2.1 :140 > arr.length
			    => 7 
			    
			b). 3.2.1 :141 > arr.count
			    => 7 
			    
			c). 3.2.1 :142 > arr.empty?
			    => false 
			 
			d). 3.2.1 :143 > arr.include?(5)
			    => true 

	11). Adding Items to Arrays :-
	
		eg :-
			a). 3.2.1 :145 > arr.push(8)
			    => [1, 2, 3, 4, 5, 6, 7, 8] 
			 
			b). 3.2.1 :146 > arr << 9
			    => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
			 
			c). 3.2.1 :147 > arr.unshift(0)              #insert at beginning
			    => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
			 
			d). 3.2.1 :148 > arr.insert(3,'apple')       #insert at specific position
			    => [0, 1, 2, "apple", 3, 4, 5, 6, 7, 8, 9] 
			 
			e). 3.2.1 :149 > arr.insert(3,'apple','orange','banana')   #insert multiple values at specific position
			    => [0, 1, 2, "apple", "orange", "banana", "apple", 3, 4, 5, 6, 7, 8, 9] 

	12). Removing Items from an Array :-
	
		eg :- 
			a). 3.2.1 :151 > arr.pop        #remove from last
			    => 9 
			 
			b). 3.2.1 :152 > arr.shift      #remove from starting
			    => 0 
			 
			c). 3.2.1 :153 > arr.delete_at(3)    #delete at specific position
			    => "orange" 
			 
			d). 3.2.1 :154 > arr.delete(5)   #delete every 5 from array
			    => 5 
			 
			inputs :-	3.2.1 :156 > arr.insert(3,nil)
					 => [1, 2, "apple", nil, "nil", "banana", "apple", 3, 4, 6, 7, 8] 
					3.2.1 :157 > arr.insert(5,nil)
					 => [1, 2, "apple", nil, "nil", nil, "banana", "apple", 3, 4, 6, 7, 8] 
					3.2.1 :158 > arr.push(7)
					 => [1, 2, "apple", nil, "nil", nil, "banana", "apple", 3, 4, 6, 7, 8, 7] 
					3.2.1 :159 > arr.push(1)
					 => [1, 2, "apple", nil, "nil", nil, "banana", "apple", 3, 4, 6, 7, 8, 7, 1] 
					 
			 
			e). 3.2.1 :160 > arr.compact		#remove nil values
			    => [1, 2, "apple", "nil", "banana", "apple", 3, 4, 6, 7, 8, 7, 1] 
			 
			f). 3.2.1 :161 > arr.uniq 		#remove duplicate values
			    => [1, 2, "apple", nil, "nil", "banana", 3, 4, 6, 7, 8] 

	13). Iterating over Arrays :-
	
		eg :- 
		
			a). 3.2.1 :168 > arr = [1, 2, 3, 4, 5]
			    3.2.1 :169 > arr.each {|a| print a -= 10, " "}
			    -9 -8 -7 -6 -5  => [1, 2, 3, 4, 5] 
			    
			b). 3.2.1 :170 > words = %w[first second third fourth fifth sixth]    #%w is used to create array of string seperated by whitespace.
			
			    => ["first", "second", "third", "fourth", "fifth", "sixth"] 
			    3.2.1 :171 > str = ""
			    3.2.1 :172 > words.reverse_each {|word| str += "#{word} "}
			    => ["first", "second", "third", "fourth", "fifth", "sixth"] 
			    3.2.1 :174 > print str
			    sixth fifth fourth third second first  => nil 
			
			c). 3.2.1 :175 > arr = [1,2,3,4,5]
			    => [1, 2, 3, 4, 5] 
			 
			d). 3.2.1 :179 > arr.map{ |a| a*2}   #multiply each element by 2
			    => [2, 4, 6, 8, 10] 
			    
			e). 3.2.1 :180 > arr.map{|a| 2**a}   
			    => [2, 4, 8, 16, 32] 
			    
			f). 3.2.1 :181 > arr.map{ |a| a**2}  #apply power 
			    => [1, 4, 9, 16, 25] 

	14). Selecting Items from an Array :-
	
		a). Non-destructive Selection
			eg :-
				3.2.1 :005 > arr.drop_while {|a| a<4}
				 => [4, 5] 
				 
				3.2.1 :006 > arr.select{|a| a>3}
				 => [4, 5] 
				 
				3.2.1 :007 > arr.reject{|a| a<3}
				 => [3, 4, 5] 
				
		b). Destructive selection
		-> Similar to select vs. reject, delete_if and keep_if have the exact opposite result when supplied with the same block:

			eg :-
				3.2.1 :008 > arr          #delete if
				 => [1, 2, 3, 4, 5] 
				3.2.1 :009 > arr.delete_if{|a| a>3}
				 => [1, 2, 3] 
				 
				 
				3.2.1 :010 > arr.keep_if{|a| a<3}     #keep if
				 => [1, 2] 
				3.2.1 :011 > arr
				 => [1, 2] 

	15). Methods for Querying :-
	
		a). all?: Returns whether all elements meet a given criterion.
		
			eg :-   3.2.1 :017 > arr
				 => [1, 2, 3, 4, 5] 
				3.2.1 :018 > arr.all?{|a| a<6}
				 => true 

		b). any?: Returns whether any element meets a given criterion.
		
			eg :-   3.2.1 :019 > arr.any?{|a| a>3}
				 => true 
				
		c). none?: Returns whether no element == a given object.
		
			eg :-   3.2.1 :020 > arr.none?{|a| a>7}
				 => true 
				
		d). one?: Returns whether exactly one element == a given object.
		
			eg :-   3.2.1 :021 > arr.one?{|a| a>7}
				 => false 
			
		e). find_index, index: Returns the index of the first element that meets a given criterion.
		
			eg :-   3.2.1 :022 > arr.index{|a| a == 3}
				 => 2 
				
		f). rindex: Returns the index of the last element that meets a given criterion.
		
			eg :-   3.2.1 :023 > arr.rindex{|a| a == 3}
				 => 2 
				
		g). hash: Returns the integer hash code.
		
			eg :-   3.2.1 :024 > arr.hash{|a| a == 3}
				 => 2802280231947848363 

	16). Methods for Fetching :-
	
		a). max: Returns one or more maximum-valued elements, as determined by <=> or a given block.
		
			eg :-
				3.2.1 :025 > arr
				 => [1, 2, 3, 4, 5] 
				3.2.1 :026 > arr.max
				 => 5 
				
		b). min: Returns one or more minimum-valued elements, as determined by <=> or a given block.
		
			eg :-
				3.2.1 :027 > arr.min
				 => 1 
				
		c). minmax: Returns the minimum-valued and maximum-valued elements, as determined by <=> or a given block.
		
			eg :-
				3.2.1 :028 > arr.minmax
				 => [1, 5] 

		d). assoc: Returns the first element that is an array whose first element == a given object.
			
			eg :-
				 3.2.1 :032 > arr1 = [[1,"ram"],[2,"ravi"],[3,"dev"]]
				 => [[1, "ram"], [2, "ravi"], [3, "dev"]] 
				 
				 3.2.1 :034 > arr1.assoc(2)
				 => [2, "ravi"] 

		e). rassoc: Returns the first element that is an array whose second element == a given object.
		
			eg :-
				 3.2.1 :038 > arr1.rassoc('dev')
				 => [3, "dev"] 

		f). at: Returns the element at a given offset.
		
			eg :-
				3.2.1 :039 > arr
				 => [1, 2, 3, 4, 5] 
				3.2.1 :040 > arr.at(4)
				 => 5 

		g). values_at: Returns the elements at given offsets.
		
			eg :-  
				3.2.1 :041 > arr.values_at(2,4)
				=> [3, 5] 		
	
		h). dig: Returns the object in nested objects that is specified by a given index and additional arguments.
		
			eg :-
				3.2.1 :043 > earth = {a: {b: {c:54}}}
				=> {:a=>{:b=>{:c=>54}}} 
				
				3.2.1 :047 > earth.dig(:a, :b, :c)
				=> 54 
				3.2.1 :048 > earth.dig(:a, :b, :d)
				=> nil 

		i). drop: Returns trailing elements as determined by a given index.
		
			eg :- 
				3.2.1 :049 > arr
				 => [1, 2, 3, 4, 5] 
				3.2.1 :050 > arr.drop(2)
				 => [3, 4, 5] 

		j). take: Returns leading elements as determined by a given index.
		
			eg :-
				3.2.1 :051 > arr.take(2)
				 => [1, 2] 

		k). drop_while: Returns trailing elements as determined by a given block.
		
			eg :-
				 3.2.1 :052 > arr.drop_while{|a| a<4}
				 => [4, 5] 

		l). take_while: Returns leading elements as determined by a given block.
		
			eg :-
				3.2.1 :054 > arr.take_while{|a| a<4}
				=> [1, 2, 3] 

		m). slice: Returns consecutive elements as determined by a given argument.
		
			eg :-
				3.2.1 :056 > arr.slice(1,3)
				 => [2, 3, 4] 
				3.2.1 :057 > arr.slice(1..3)
				 => [2, 3, 4] 
				3.2.1 :058 > arr.slice(1...3)
				 => [2, 3] 

		n). select, filter: Returns an array containing elements selected by a given block.
		
			eg :- 
				3.2.1 :059 > arr.select{|a| a%2 == 0}
				 => [2, 4] 
				
		o). rotate: Returns all elements with some rotated from one end to the other.
		
			eg :-
				3.2.1 :060 > arr.rotate(3)
				 => [4, 5, 1, 2, 3] 

		p). bsearch: Returns an element selected via a binary search as determined by a given block.
		
			eg :-
				3.2.1 :065 > arr
				 => [1, 2, 3, 4, 5] 
				3.2.1 :066 > arr.bsearch{|x| x>=3}
				 => 3 
				
		q). bsearch_index: Returns the index of an element selected via a binary search as determined by a given block.
		
			eg :-
				3.2.1 :067 > arr.bsearch_index{|x| x>=3}
				 => 2 

		r). sample: Returns one or more random elements.
		
			eg :-
				3.2.1 :069 > arr.sample(2)
				 => [1, 5] 
				
		s). shuffle: Returns elements in a random order.
		
			eg :-
				3.2.1 :070 > arr.shuffle
				 => [2, 5, 1, 3, 4] 
				3.2.1 :071 > arr.shuffle
				 => [3, 5, 2, 1, 4] 

--------------------------------------------------------------------------------------------------------------------------------------
							         STRINGS

 -> A String object in Ruby holds and manipulates an arbitrary sequence of one or more bytes.
 -> typically representing characters that represent human language.
 
 	eg :- 'This is a simple Ruby string literal'
 	
 -> If you need to place an apostrophe within a single-quoted string literal, precede it with a backslash.
 
        eg :- 'Won\'t you read O\'Reilly\'s book?'

	1). Expression Substitution
		-> it is a means of embedding the value of any Ruby expression into a string using #{ and } −
		
		eg:-
			x, y, z = 12, 36, 72
			puts "The value of x is #{ x }."
			puts "The sum of x and y is #{ x + y }."
			puts "The average was #{ (x + y + z)/3 }."
			
		output :- The value of x is 12.
			  The sum of x and y is 48.
			  The average was 40.
			  
	2). General Delimited Strings
		-> you can create strings inside a pair of matching though arbitrary delimiter characters, e.g., !, (, {, <, etc., preceded by a percent character (%). 
		-> Q, q, and x have special meanings. 
		-> General delimited strings can be :-

			%{Ruby is fun.}  equivalent to "Ruby is fun."
			%Q{ Ruby is fun. } equivalent to " Ruby is fun. "
			%q[Ruby is fun.]  equivalent to a single-quoted string
			%x!ls! equivalent to back tick command output `ls`
			
	3). substitute(sub) and global substitute(gsub).
	
		-> s.sub(/[aeiou]/, '*')# => "h*llo"
		-> s.gsub(/[aeiou]/, '*') # => "h*ll*"
	
	4). Hash replacement :- 
	-> If argument replacement is a hash, and pattern matches one of its keys, the replacing string is the value for that key
	
		eg :-  3.2.1 :148 > h = {'app'=>'purp' , 'le' => 'ly'}
			 => {"app"=>"purp", "le"=>"ly"} 
			3.2.1 :149 > apple.sub('app',h)
			
		output :-
			3.2.1 :150 > 'apple'.sub('app',h)
			 => "purple" 
			3.2.1 :151 > 'apple'.sub('le',h)
			 => "apply" 
			 
	5). String Slices :-

	-> A slice of a string is a substring that is selected by certain criteria.
	-> Types of slicing
		a). string[index].
		
			eg :-  3.2.1 :166 > str
				 => "sachin" 
				3.2.1 :167 > str[0]
				 => "s" 
				3.2.1 :168 > str[3]
				 => "h" 
				3.2.1 :169 > str[-2]
 				=> "i" 


		b). string[start, length].    #between some range
		
			eg :- 	3.2.1 :170 > str[0,4]
				 => "sach" 
				3.2.1 :173 > str[2,5]
				 => "chin" 

		c). string[range].
		
			eg :-   3.2.1 :174 > str[1..4]
				 => "achi" 
				3.2.1 :175 > str[1...4]
				 => "ach" 
				3.2.1 :176 > str[2..200]
				 => "chin" 

		d). string[regexp, capture = 0].
		
		eg :-   s = 'saaaccchinn' 
			3.2.1 :195 > s[/[aeiou]/]   # find first vowel letter
			 => "a" 
			3.2.1 :196 > s[/[aeiou](.)/]   # "." for add next element after first vowel
			 => "aa" 
			3.2.1 :197 > s[/[aeiou](.)\1/]  # "\1" for add all similer letter after the first vowel but must be consecutive
			 => "aaa" 
			3.2.1 :198 > s[/[aeiou](.)\1/,0]
			 => "aaa" 
			3.2.1 :199 > s[/[aeiou](.)\1/,1] # "1" consecutive similer letter limit to 1.
			 => "a" 

		e). string[substring].   #search for substring in the string.
		
			eg :-   3.2.1 :201 > s['aa']
				 => "aa" 
				3.2.1 :202 > s['zzz']
				 => nil 
				 
	6). Methods for Creating a String :-
	
		a). ::new: Returns a new string.
		
			eg :- str = String.new("hello")

		b). ::try_convert: Returns a new string created from a given object.
			-> try to convert into string.

		 	eg :-   arr = ["h", "e", "l", "l", "o"]
				str = String.try_convert(arr)          #try to convert the array into the string and store into str.
		
	7). Methods for a Frozen/Unfrozen String :-
	
		a). Frozen -> A frozen string cannot be modified.
			    -> Any attempt to modify a frozen string will result in a RuntimeError. 
			    
			   -> To make string freeze.
			      syntax :- str = "something".frozen
			    	
			   -> To check frozen or not.
			      syntax :- str.frozen?       #provide true or false value as output.
			
			eg :-   
				3.2.1 :212 > str1 = 'something'.freeze    
				 => "something" 				#frozen string
				3.2.1 :213 > str2 = 'not_something'
				 => "not_something" 				#unfrozen string
				3.2.1 :214 > str1.frozen?
				 => true 
				3.2.1 :215 > str2.frozen?
				 => false 
		b). #dup  -> This method creates a copy of the string that is not frozen. 
			   -> allowing it to be modified.
			   -> dup make duplicate which is a shallow copy.

			eg :-
				str1 = "hello".freeze
				str2 = str1.dup                     #replace of dup is clone which is a deep copy method of string.

				begin
				  str2[0] = "H"
				rescue RuntimeError => e
				  puts e.message #=> can't modify frozen String
				end
			
			output :- through error because of shallow copy.
			
		c). #concat  -> This method appends a string to the end of the current string.
			     -> returning a new string that is not frozen.

			eg :-
				str1 = "hello".freeze
				str2 = "world"

				str3 = str1.concat(str2)

				puts str3 #=> "helloworld"
				puts str3.frozen? #=> false	
				
			output :- concat string is not frozen .
			
	8). Methods for Querying
	
	  a) count :-
		length, size: Returns the count of characters (not bytes).
		
			eg :-
				3.2.1 :216 > str1.length
				 => 9 
				3.2.1 :217 > str1.size
				 => 9 
		
		empty? : Returns true if self.length is zero; false otherwise.
			
			eg :- 
				3.2.1 :218 > str1.empty?
 				=> false 

		bytesize : Returns the count of bytes.
		
			eg :- 
				3.2.1 :219 > str1.bytesize
 				=> 9 

		count : Returns the count of substrings matching given strings.
		
			eg :- 
				3.2.1 :225 > str1.count('e')
 				=> 1 
			
	  b) Substrings :-

		=~ : Returns index of the first substring that matches a given object, nil if no match is found.
		
			eg :- 
				3.2.1 :237 > string
 				=> "The quick brown fox jumps over the lazy dog" 
 				
 				3.2.1 :227 > if string =~ /brown/
				3.2.1 :228 >   puts "Match found at index #{$~.begin(0)}"
				3.2.1 :229 > else
				3.2.1 :230 >   puts "No match found"
				3.2.1 :231 > end
				Match found at index 10


		index : Returns the index of the first occurrence of a given substring; returns nil if none found.
		
			eg :- 
				3.2.1 :238 > string.index('he')
				 => 1 

		rindex : Returns the index of the last occurrence of a given substring; returns nil if none found.
		
			eg :-
				3.2.1 :239 > string.rindex('he')
				 => 32 

		include? : Returns true if the string contains a given substring; false otherwise.
		
			eg :-
				3.2.1 :241 > string.include?('brown')
				 => true 

		match : Returns a MatchData object if the string matches a given Regexp; nil otherwise.
		
			eg :-
				3.2.1 :243 > match_str = string.match(/fox/)
				=> #<MatchData "fox"> 
				
				3.2.1 :249 > if match_str
				3.2.1 :250 >   print "match found for the string"
				3.2.1 :251 > else
				3.2.1 :252 >   print "match not found"
				3.2.1 :253 > end
				match found for the string => nil 

		match? : Returns true if the string matches a given Regexp; false otherwise.
		
			eg :- 
				3.2.1 :255 > string.match?('fox')
				=> true 

		start_with?: Returns true if the string begins with any of the given substrings.
		
			eg :- 
				3.2.1 :263 > string.start_with?('The')
				 => true 
				3.2.1 :264 > string.start_with?('he')
				 => false 

		end_with? : Returns true if the string ends with any of the given substrings.
		
			eg :- 
				3.2.1 :259 > string.end_with?('dog')
				 => true 
				3.2.1 :260 > string.end_with?('do')
				 => false 
				 
	  c). Encodings
	  
	        Retrieving the encoding of a string: You can use the encoding method to retrieve the encoding of a string.

				eg :-
				string = "hello"
				puts string.encoding # prints "UTF-8"

		Converting a string to a different encoding: You can use the encode method to convert a string to a different encoding.

				eg :-
				string = "héllo"
				utf8_string = string.encode("UTF-8")
				puts utf8_string # prints "héllo" (encoded in UTF-8)
				
		Checking if a string is valid in a specific encoding: You can use the valid_encoding?
									method to check if a string is valid in a specific encoding.
				eg :-
				string = "héllo"
				puts string.valid_encoding? # prints true
				ascii_string = string.encode("ASCII")
				puts ascii_string.valid_encoding? # prints false

		Forcing a string to a specific encoding: You can use the force_encoding method to force a string to a specific encoding.

				eg :-
				string = "héllo".force_encoding("ASCII")
				puts string.valid_encoding? # prints false
				
		unicode_normalized?: Returns true if the string is in Unicode normalized form; false otherwise.
		
				eg :-
				3.2.1 :275 > string.unicode_normalized?
 				=> true 
		
		ascii_only?: Returns true if the string has only ASCII characters; false otherwise.
				
				eg :-
				3.2.1 :274 > string.ascii_only?
 				=> true 

	  d). checksum or hash code :-
	  
	  	sum: This method returns a basic checksum for the string by computing the sum of the ASCII or binary values of each byte in the string. 

				eg :-
				string = "hello"
				checksum = string.sum
				
				puts checksum # prints 532

	NOTE :-sum method computes the sum of the ASCII values of each byte in the string ("h" is 104, "e" is 101, etc.) and returns the integer result.

		hash: This method returns an integer hash code for the string.
		      which is a value that can be used to quickly identify the string and compare it with other strings. 
		      The hash code is computed using a hash function that takes into account the values of each byte in the string.

				eg :- 
				string = "hello"
				hash_code = string.hash
				
				puts hash_code # prints 8664480119899782111

	9). Methods for Comparing :-
	
		a). ==, === : Returns true if a given other string has the same content as self.
		b). eql?    : Returns true if the content is the same as the given other string. 
		c). #<=>    : Returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than self.

		d). casecmp : Ignoring case, returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than self.
		
			 0: The two strings are equal in a case-insensitive comparison.
			-1: The first string is less than the second string in a case-insensitive comparison.
			 1: The first string is greater than the second string in a case-insensitive comparison.

			eg :-  
				3.2.1 :276 > st1 = 'HELLO'
				 => "HELLO" 
				3.2.1 :277 > st2 = 'hElLO'
				 => "hElLO" 
				3.2.1 :278 > st1.casecmp(st2)
				 => 0 

		e). casecmp?: Returns true if the string is equal to a given string after Unicode case folding; false otherwise.

			eg :- 
				3.2.1 :280 > st1.casecmp?(st2)
 			        => true 

	10). Methods for Modifying a String :-
	 
		a). Insertion :-

			insert: Returns self with a given string inserted at a given offset.
			
				eg :-
				3.2.1 :283 > st3 = 'ram'
 				=> "ram" 
				3.2.1 :284 > st3.insert(2,'aa')
				=> "raaam" 

			<< : Returns self concatenated with a given string or integer.
			
				eg :-
				3.2.1 :282 > st1 << ' WORLD'
				=> "HELLO WORLD" 

		b). Substitution :-

			*). sub!: Replaces the first substring that matches a given pattern with a given replacement string.
			    -> returns self if any changes, nil otherwise.     #destructive versions 
			    
			    eg :-
			    	3.2.1 :288 > st1
				 => "HELLO WORLD" 
				3.2.1 :289 > st1.sub!('WORLD','RUBY')
				 => "HELLO RUBY" 
				3.2.1 :290 > st1
				 => "HELLO RUBY" 


			*). gsub!: Replaces each substring that matches a given pattern with a given replacement string. 
			    -> returns self if any changes, nil otherwise.     #destructive versions 
			    
			    eg :-
			    	3.2.1 :291 > string
 				=> "The quick brown fox jumps over the lazy dog" 
 				3.2.1 :293 > string.gsub!('The','the')
 				=> "the quick brown fox jumps over the lazy dog" 
 				
			*). succ!, next!: Returns self modified to become its own successor.
			    -> Both methods are destructive and modify the string in place.
			    
			    eg :-
			    	3.2.1 :294 > st1.succ
				 => "HELLO RUBZ" 
				3.2.1 :295 > st1.succ
				 => "HELLO RUBZ" 
				3.2.1 :296 > st1.succ!
				 => "HELLO RUBZ" 
				3.2.1 :297 > st1.succ!
				 => "HELLO RUCA" 
				 
				 
				 3.2.1 :299 > st1.next!        #for next! similer to succ!
				 => "HELLO RUCB" 
				 3.2.1 :300 > st1.next!
				 => "HELLO RUCC" 
				 3.2.1 :301 > st1.next!

			*). replace: Returns self with its entire content replaced by a given string.
			
				eg :-
					3.2.1 :303 > st1
					 => "HELLO RUCF" 
					3.2.1 :304 > st2
					 => "hElLO" 
					3.2.1 :305 > st1.replace(st2)
					 => "hElLO" 
					3.2.1 :306 > st1
					 => "hElLO" 


			*). reverse!: Returns self with its characters in reverse order.
			
				eg :-
					3.2.1 :307 > st1.reverse!
					=> "OLlEh" 

			*). setbyte: Sets the byte at a given integer offset to a given value; returns the argument.
			
				eg :-
					3.2.1 :310 > st1.setbyte(0, 72)
					 => 72 
					3.2.1 :311 > st1
					 => "HElLO" 

			*). tr!: Replaces specified characters in self with specified replacement characters. 
			    returns self if any changes, nil otherwise.
			    
			    	eg :-
			    		3.2.1 :314 > st4 = 'hhellooo wworldd'
					 => "hhellooo wworldd" 
					3.2.1 :315 > st4.tr!("aeiou","&")
					 => "hh&ll&&& ww&rldd" 
					3.2.1 :316 > st4
					 => "hh&ll&&& ww&rldd" 
			    		
			*). tr_s!: Replaces specified characters in self with specified replacement characters. 
			    removing duplicates from the substrings that were modified; returns self if any changes, nil otherwise.
			    
			    	eg :-
			    		3.2.1 :317 > st5 = 'hhelloo wworld'
					 => "hhelloo wworld" 
					3.2.1 :318 > st5.tr_s!("aeiou","*")
					 => "hh*ll* ww*rld" 
					 
		c). Casing :-

			*). capitalize!: Upcases the initial character and downcases all others.
				-> returns self if any changes, nil otherwise.
				
				eg :-
					3.2.1 :319 > st6 = 'beryl system'
					 => "beryl system" 
					3.2.1 :320 > st6.capitalize!
					 => "Beryl system" 

			*). downcase!: Downcases all characters; returns self if any changes, nil otherwise.
			
				eg :- 
					 3.2.1 :322 > st6.downcase!
					 => "beryl system" 

			*). upcase!: Upcases all characters; returns self if any changes, nil otherwise.
			
				eg :-
					3.2.1 :321 > st6.upcase!
					 => "BERYL SYSTEM" 

			*). swapcase!: Upcases each downcase character and downcases each upcase character.
				-> returns self if any changes, nil otherwise.
				
				eg :-
					3.2.1 :325 > st6.swapcase!
					 => "bERYL SYSTEM" 
					 
		d). Encoding :-
			
		*). scrub!: This method is used to replace any invalid byte sequences in a string with a given replacement character. 
		  -> It returns the modified string with the invalid byte sequences replaced. 
		  -> The original string is modified in place. Here's an example:

			eg :-
				str = "hello\xE9world"
				str.scrub!("*")
				puts str # outputs: "hello*world"

		e). Deletion :-
		
			*). clear: Removes all content, so that self is empty; returns self.
			
				eg :-
					3.2.1 :327 > st6.clear
					=> "" 

			*). slice!, []=: Removes a substring determined by a given index, start/length, range, regexp, or substring.
			
				eg :-
					3.2.1 :328 > st5
					 => "hh*ll* ww*rld" 
					3.2.1 :329 > st5.slice!(2,5)
					 => "*ll* " 
					3.2.1 :330 > st5
					 => "hhww*rld" 

			*). squeeze!: Removes contiguous duplicate characters; returns self.
			
				eg :-
					3.2.1 :331 > st5.squeeze!
 					=> "hw*rld" 

			*). delete!: Removes characters as determined by the intersection of substring arguments.
			
				eg :-
					3.2.1 :332 > st3
					 => "raaam" 
					3.2.1 :333 > st3.delete!('aeiou')
					 => "rm" 

			*). lstrip!: Removes leading whitespace; returns self if any changes, nil otherwise.
			
				eg :-
					3.2.1 :338 > st7 = '    there is an apple    '
					 => "    there is an apple    " 
					3.2.1 :339 > st7.lstrip!
					 => "there is an apple    " 

			*). rstrip!: Removes trailing whitespace; returns self if any changes, nil otherwise.
			
				eg :-
					3.2.1 :340 > st7.rstrip!
					=> "there is an apple" 

			*). strip!: Removes leading and trailing whitespace; returns self if any changes, nil otherwise.
			
				eg :-
					3.2.1 :344 > st8
					 => "     there is a banana    " 
					3.2.1 :345 > st8.strip!
					 => "there is a banana" 

			*). chomp!: Removes trailing record separator, if found; returns self if any changes, nil otherwise.
				->  (i.e., "\n", "\r", or "\r\n") 
				
				eg :-
					3.2.1 :347 > st9 = "hello \n world \n\r"
					=> "hello \n world \n\r" 
					
					3.2.1 :349 > st9.chomp!
					 => "hello \n world \n" 
					3.2.1 :350 > st9.chomp!
					 => "hello \n world " 


			*). chop!: Removes trailing newline characters if found; otherwise removes the last character.
				-> returns self if any changes, nil otherwise.
				
				eg :-
					3.2.1 :354 > st9.chop!
					 => "hello \n world" 
					3.2.1 :355 > st9.chop!
					 => "hello \n worl" 
					3.2.1 :356 > st9.chop!
					 => "hello \n wor" 

	11). Methods for Converting to New String:-
	
		a). Extension :-
		
			*). *: Returns a new string that is the concatenation of the original string repeated a given number of times. 
			
				eg:-
				3.2.1 :361 > st9 = "sachin "
				 => "sachin " 
				3.2.1 :362 > st9*3
				 => "sachin sachin sachin " 

			*). +: Returns a new string that is the concatenation of the original string and another given string. 
			
				eg:- 
				3.2.1 :364 > st9 + 'kanojia'
				=> "sachin kanojia" 

			*). center: This method returns a new string that is padded with a given substring to a certain length.
			    -> with the original string centered in between the padding. 
			   
			   	eg:-
			   	3.2.1 :368 > st9.center(10,"-")     #10 specify the number of character in string.
				=> "--sachin--" 
 

			*). concat: appends the given strings to the end of the original string and returns the modified string. 
			
				eg:-
				3.2.1 :369 > st9
				 => "sachin" 
				3.2.1 :370 > st9.concat('kanojia')
				 => "sachinkanojia" 

			*). prepend: prepends the given string to the beginning of the original string and returns the modified string. 
			
				eg:-
				 3.2.1 :371 > st9.prepend('Hello ')
				 => "Hello sachinkanojia" 

			*). ljust: This method returns a new string that is padded with a given substring to a certain length.
			    -> with the original string left-justified. 
			    
			    	eg:-
			    	3.2.1 :374 > st9.ljust(25,'-')
				 => "Hello sachinkanojia------" 
				
			*). rjust: This method returns a new string that is padded with a given substring to a certain length.
			    -> with the original string right-justified. 
			    
			    	eg:-
			    	3.2.1 :375 > st9.rjust(25,'-')
				 => "------Hello sachinkanojia" 
				 
		b). Encoding

			*). b: Returns a copy of self with ASCII-8BIT encoding.
			
				eg :-   3.2.1 :007 > st1.encoding
					 => #<Encoding:UTF-8> 
					3.2.1 :008 > st2 = st1.b
					 => "sachin" 
					3.2.1 :009 > st2.encoding
					 => #<Encoding:ASCII-8BIT> 

			*). scrub: Returns a copy of self with each invalid byte replaced with a given character.
				
				eg :-   3.2.1 :016 > str = "Hello, \xFFworld!"
					 => "Hello, \xFFworld!" 
					3.2.1 :017 > scrubbed_str = str.scrub('?')
					3.2.1 :018 > puts scrubbed_str
					Hello, ?world!
					
		c). Substitution

			*). dump: Returns a copy of self with all non-printing characters replaced by xHH notation and all special characters escaped.
				eg :-   3.2.1 :019 > str = "Hello, \tworld!\n"
					 => "Hello, \tworld!\n" 
					 
					3.2.1 :020 > str3 = str.dump
					 => "\"Hello, \\tworld!\\n\"" 
					
			*). undump: Returns a copy of self with all \xNN notation replace by \uNNNN notation and all escaped characters unescaped.
				eg :-   3.2.1 :021 > str4 = str3.undump
					 => "Hello, \tworld!\n" 

		d). Deletion

			*). delete: Returns a copy of self with characters removed
			
				eg :-   3.2.1 :030 > str
					 => "Hello, \tworld!\n" 
					3.2.1 :031 > str.delete('llo')
					 => "He, \twrd!\n" 

			*). delete_prefix: Returns a copy of self with a given prefix removed.
			
				eg :-   3.2.1 :032 > str.delete_prefix('Hello, ')
					 => "\tworld!\n" 

			*). delete_suffix: Returns a copy of self with a given suffix removed.
			
				eg :-   3.2.1 :037 > str = "Hello, world!"
					3.2.1 :038 > new_str = str.delete_suffix(", world!")
					 => "Hello" 

			*). chr: Returns the first character.

				eg :-   3.2.1 :040 > str
					 => "Hello, world!" 
					3.2.1 :041 > str.chr
					 => "H" 

		e). Duplication

			*). to_s, $to_str: If self is a subclass of String, returns self copied into a String; otherwise, returns self.
				
				eg :-
					3.2.1 :042 > a = 45
					 => 45 
					3.2.1 :043 > b = a.to_s
					 => "45" 
					3.2.1 :044 > b.class
					 => String 

	12). Methods for Converting to Non-String

		a). Characters, Bytes, and Clusters

			*). bytes: Returns an array of the bytes in self.
			
				eg :-   3.2.1 :054 > str.bytes
 					=> [104, 101, 108, 108, 111] 


			*). chars: Returns an array of the characters in self.
			
				eg :-   3.2.1 :047 > str.chars
					 => ["h", "e", "l", "l", "o"] 

			*). codepoints: Returns an array of the integer ordinals in self, have values greater than 255.
			
				eg :-   3.2.1 :048 > str.codepoints
					 => [104, 101, 108, 108, 111] 
					
			*). getbyte: Returns an integer byte as determined by a given index.
			
				eg :-   3.2.1 :049 > str.getbyte(1)
					 => 101 
					
			*). grapheme_clusters: Returns an array of the grapheme clusters in self, also works on emojis.
			
				eg :-   3.2.1 :050 > str.grapheme_clusters
					 => ["h", "e", "l", "l", "o"] 
					3.2.1 :051 > str = "😇"
					 => "😇" 
					3.2.1 :052 > str.grapheme_clusters
					 => ["😇"] 

		b). Splitting

			*). lines: Returns an array of the lines in self, as determined by a given record separator.
			
				eg :-   3.2.1 :055 > str = "Line 1\nLine 2\nLine 3"
					 => "Line 1\nLine 2\nLine 3" 
					3.2.1 :056 > str.lines
					 => ["Line 1\n", "Line 2\n", "Line 3"] 

			*). partition: Returns a 3-element array determined by the first substring that matches a given substring or regexp,
				eg :-   3.2.1 :058 > str = 'hello , world'
					 => "hello , world" 
					3.2.1 :059 > str.partition(',')
					 => ["hello ", ",", " world"] 
				
			*). rpartition: Returns a 3-element array determined by the last substring that matches a given substring or regexp,
				eg :-   3.2.1 :060 > str = 'hello world , again'
					 => "hello world , again" 
					3.2.1 :061 > str.rpartition(',')
					 => ["hello world ", ",", " again"] 

			*). split: Returns an array of substrings determined by a given delimiter – regexp or string – or, if a block given, passes those substrings to the block.
			
				eg :-   3.2.1 :062 > str = 'hello , world , again'
					 => "hello , world , again" 
					3.2.1 :063 > str.split(',')
					 => ["hello ", " world ", " again"] 
					 
		c). Matching

			*). scan: Returns an array of substrings matching a given regexp or string, or, if a block given, passes each matching substring to the block.
				eg :-   3.2.1 :065 > str.scan(/[aeiou]/)
					 => ["e", "o", "o", "a", "a", "i"] 
					3.2.1 :066 > str = "\x01\x02\x03"
					 => "\u0001\u0002\u0003" 

			*). unpack: Returns an array of substrings extracted from self according to a given format.
			
				eg :-   3.2.1 :068 > str.unpack('c*')
					 => [1, 2, 3] 
					
			*). unpack1: Returns the first substring extracted from self according to a given format.
			
				eg :-   3.2.1 :069 > str.unpack1('c*')
					 => 1 
					 
		d). Numerics

			*). hex: Returns the integer value of the leading characters, interpreted as hexadecimal digits.
			
				eg :-   3.2.1 :080 > str
					 => "2AB" 
					3.2.1 :081 > str.hex
					 => 683 

			*). oct: Returns the integer value of the leading characters, interpreted as octal digits.
			
				eg :-   3.2.1 :082 > str.oct
					 => 2 

			*). ord: Returns the integer ordinal of the first character in self.
			
				eg :-   3.2.1 :083 > str.ord
					 => 50 

			*). to_i: Returns the integer value of leading characters, interpreted as an integer.
			
				eg :-   3.2.1 :078 > str.to_i
					 => 2 

			*). to_f: Returns the floating-point value of leading characters, interpreted as a floating-point number.
			
				eg :-   3.2.1 :079 > str.to_f
					 => 2.0 
					 
		e). Strings and Symbols

			*). inspect: Returns copy of self, enclosed in double-quotes, with special characters escaped.
			
				eg :-   3.2.1 :084 > str = 'hello\nworld'
					 => "hello\\nworld" 
					3.2.1 :085 > str.inspect
					 => "\"hello\\\\nworld\"" 
					
			*). to_sym, intern: Returns the symbol corresponding to self.
			
				eg :-   3.2.1 :086 > str.to_sym
					 => :"hello\\nworld" 
					 
	13). Methods for Iterating
	
			*). each_byte: Calls the given block with each successive byte in self.
			
				eg :-   3.2.1 :096 > str.each_byte{ |a| puts a}
					104
					101                                                             
					108                                                             
					108                                                             
					111                                                             
					 => "hello"                                                     
					
			*). each_char: Calls the given block with each successive character in self.
			
				eg :-   3.2.1 :097 > str.each_char{ |a| puts a}
					h
					e                                                               
					l                                                               
					l                                                               
					o                                                               
					 => "hello"                                                     
					
			*). each_codepoint: Calls the given block with each successive integer codepoint in self.
			
				eg :-   3.2.1 :098 > str.each_codepoint{ |a| puts a}
					104
					101                                   
					108                                   
					108                                   
					111                                   
					 => "hello" 

			*). each_grapheme_cluster: Calls the given block with each successive grapheme cluster in self.
			
				eg :-   3.2.1 :099 > str.each_grapheme_cluster{ |a| puts a}
					h
					e                                     
					l                                     
					l                                     
					o                                     
					 => "hello" 

			*). each_line: Calls the given block with each successive line in self, as determined by a given record separator.
			
				eg :-   3.2.1 :107 > str = "hello \n world"
					 => "hello \n world" 
					3.2.1 :108 > str.each_line{|a| puts a}
					hello 
					 world                                                         
					 => "hello \n world"                                           

			*). upto: Calls the given block with each string value returned by successive calls to succ.
			
				eg :-   3.2.1 :105 > "a".upto("d") { |str| puts str }
					a
					b                                                                               
					c                                                                               
					d                                                                               
					 => "a"  






